#+TITLE: Org-Roam, References and the Zettelkasten Workflow

This file is a core part of my emacs configuration and is all about my Org-roam setup and my reference management inside org. Its based on the Zettelkasten method and the Roam Research website. Notes are linked with one another. Bibtex completion (and the existence of .bib files in general) as well as Org-ref help manage bibliographic references inside org. I also use Zotero as it easily allows me to gather my bibliographies. It exports a .bib file which these two use. Org Roam Bibtex (ORB) is a package that combines all of these to help you add citation links from org-ref inside an org-roam buffer. This section includes all the customisations and settings of these packages. This is a very large section of my config (hence why it has its own file) as I have really customised this workflow a lot.

* Table of Contents                                                     :TOC:
- [[#org-roam-general-setup][Org-Roam general setup]]
- [[#useful-functions][Useful Functions]]
- [[#bibtex-completion-ivy-and-org-ref][Bibtex completion (Ivy) and Org-Ref]]
  - [[#citar][Citar]]
- [[#org-roam-bibtex-protocols-reference-notes-and-ui-graphing-capabilities][Org Roam Bibtex, Protocols (Reference notes) and UI (graphing capabilities)]]
- [[#acting-on-backlinks][Acting on backlinks]]
  - [[#org-roam-backlinks-search][Org-roam-backlinks-search]]
  - [[#find-intersecting-backlinks-of-multiple-nodes][Find intersecting backlinks of multiple nodes]]
- [[#logseq-like-tagging-functionality][Logseq-like tagging functionality]]
- [[#fleeting-notes][Fleeting notes]]
- [[#capture-templates][Capture Templates]]
- [[#providing-the-packages-to-be-loaded-in-initel][Providing the packages to be loaded in init.el]]

* Org-Roam general setup
  This part is the general setup of org-roam. It contains the setup, removing the warning message for the migration to v2, and the use-package declaration for org-roam. There I put the org roam directory, the various defmethods I use, my display template and a resize to the org-roam buffer as taking half the screen isn't something I like. I much prefer it to be a bit smaller than the main window.

  A lot of the defmethods defined here are for my display template as I think its useful to see directories, backlink count and todo state of nodes in the org-roam-node-find UI. Then there is the oddball org-roam-node-backlinkscount-number which is identical almost to org-roam-node-backlinkscount, but its different output is useful for a function I define later and the org-roam-node-buffer defmethod which is a very helpful defmethod that imo should have been defined in org-roam. It returns the buffer associated to a node, and nil if there is none. I use this in various parts of my config and I consider it an important defmethod. 
   
 #+BEGIN_SRC elisp :tangle yes

   (add-hook 'after-init-hook 'org-roam-setup)
   (setq org-roam-v2-ack t)

   (use-package org-roam
     :config
     (setq org-roam-directory "~/org_roam/"
	   org-roam-dailies-directory "~/org_roam/daily")

     (cl-defmethod org-roam-node-directories ((node org-roam-node))
       "Access slot \"directory\" of org-roam-node struct CL-X"
       (if-let ((dirs (file-name-directory (file-relative-name (org-roam-node-file node) org-roam-directory))))
	   (format "(%s)" (car (f-split dirs)))
	 ""))

     (cl-defmethod org-roam-node-backlinkscount ((node org-roam-node))
       "Access slot \"backlinks\" of org-roam-node struct CL-X"
       (let* ((count (caar (org-roam-db-query
			    [:select (funcall count source)
				     :from links
				     :where (= dest $s1)
				     :and (= type "id")]
			    (org-roam-node-id node)))))
	 (format "[%d]" count)))

     (cl-defmethod org-roam-node-backlinkscount-number ((node org-roam-node))
       "Access slot \"backlinks\" of org-roam-node struct CL-X. This
       is identical to `org-roam-node-backlinkscount' with the
       difference that it returns a number instead of a formatted
       string. This is to be used in
       `org-roam-node-sort-by-backlinks'"
       (let* ((count (caar (org-roam-db-query
			    [:select (funcall count source)
				     :from links
				     :where (= dest $s1)
				     :and (= type "id")]
			    (org-roam-node-id node)))))
	 count))

     (cl-defmethod org-roam-node-todostate ((node org-roam-node))
       "Modified version of org-roam-node-todo to look a bit better"
       (if-let ((state (org-roam-node-todo node)))
	   (format "%s: " state)))

     (cl-defmethod org-roam-node-buffer ((node org-roam-node))
       "Access slot \"buffer\" of org-roam-node struct CL-X"
       (let ((buffer (get-file-buffer (org-roam-node-file node))))
	 buffer))

     (setq org-roam-node-display-template "${title:100} ${backlinkscount:6} ${todostate:20} ${directories:10} ${tags:15}")

     (add-to-list 'display-buffer-alist
		  '("\\*org-roam\\*"
		    (display-buffer-in-direction)
		    (direction . right)
		    (window-width . 0.40)
		    (window-height . fit-window-to-buffer))))

   #+END_SRC

* Useful Functions
   Org roam is a cornerstone of my workflow (which is the reason this file is so stupidly large). I have written various "helper" functions for my own assistance that are meant to be used with org-roam. This section includes those functions. They are all documented well so I do not think I need to describe them. 

#+BEGIN_SRC elisp :tangle yes

  (defun org-roam-buffer-without-latex ()
      "Essentially `org-roam-buffer-toggle' but it ensures latex previews are turned off before toggling the buffer.

    This is useful because especially with index files, having
    latex previews on, makes opening the buffer very slow as it
    needs to load previews of many files. If you by default have
    `org-startup-with-latex-preview' set to t, you have probably
    noticed this issue before. This function solves it."
      (interactive)
      (let ((org-startup-with-latex-preview nil))
	(org-roam-buffer-toggle)))

  (defun org-roam-permanent-note-p (NODE)
    "Check if NODE is at the top level org_roam directory using the
    `org-roam-node-directories' function. If it isn't,
    `org-roam-node-directories' will return a non empty string,
    therefore this expression will evaluate to nil. The way my
    notes are sorted, when a note is placed on the top level its a
    permanent note, while fleeting and reference notes are placed
    in subdirectories.

  Therefore, this predicate function allows me to create a version
  of `org-roam-node-find' which only shows my permanent notes,
  which can be useful in some cases. That filtered function is
  `org-roam-find-permanent-node'."
    (string-equal (org-roam-node-directories NODE) ""))

  (defun org-roam-node-poi-or-moc-p (NODE)
    "Check if NODE has the tag POI or the tag MOC. Return t if it does"
    (or (string-equal (car (org-roam-node-tags NODE)) "POI")
	(string-equal (car (org-roam-node-tags NODE)) "MOC")))

  (defun org-roam-find-permanent-node ()
    "Execute `org-roam-node-find' with the list being filtered to
  only include permanent notes. In my system that is synonymous to
  saying include only notes at the top level directory. The
  filtering is done with the `org-roam-permanent-note-p' predicate
  function."
    (interactive)
    (org-roam-node-find nil nil #'org-roam-permanent-note-p))
#+END_SRC

* Bibtex completion (Ivy), Org-Ref and Org-Cite
  Ivy Bibtex and Org ref are two excellent packages for managing bibliography. The main thing I need to configure is the location of my master .bib file and pdfs (which are exported with Zotero). I also change some other variables where I see fit.

  Since this is the section all about bibliography, I also included my org-cite configuration here. Org-cite is the standard org mode citation syntax (which is different from org-ref) that I have been willing to try.
   
  In detail
  - Zotero exports a .bib file with all my references (the main way it "talks" to Emacs). I "tell" ivy-bibtex and org-ref the location of this file for usage in their various commands.
  - I allow ivy-bibtex to query by keywords or abstract. Can be useful
  - I make the default action of ivy-bibtex, the edit notes action. Personally, its the action I use most as opening the link/pdf to the reference (which is the original default) is more easily done from Zotero imo. In Emacs I find more utility in this function creating bibliographical notes.
  - Since opening the pdf, url or DOI of a bibtex entry is no longer the default action in my config, I bind it to the letter p in the options menu of Ivy-bibtex
  - Change the citation format bibtex uses on org mode. I enter cite links with org-ref-insert-cite-links so I make the ivy-bibtex link be a link to the pdf.
  - Require org-cite, the package for org's native citation format and configure it to know where to look for bibliography, export with csl and use the ACS bibliography style
  - Require zotra, a package for getting bibliographic information using Zotero's translators, but in Emacs

#+BEGIN_SRC elisp :tangle yes
  (setq bibtex-completion-bibliography
	'("~/org_roam/My_Library.bib" "~/org_roam/My_Library2.bib")
	bibtex-completion-pdf-field "File"
	bibtex-completion-library-path '("~/Sync/Zotero_pdfs"))

  (setq bibtex-completion-additional-search-fields '(keywords abstract))

  (setq ivy-bibtex-default-action 'ivy-bibtex-edit-notes)
  (ivy-add-actions
   'ivy-bibtex
   '(("p" ivy-bibtex-open-any "Open pdf, url or DOI")))

  (setq bibtex-completion-format-citation-functions
	'((org-mode . bibtex-completion-format-citation-org-title-link-to-PDF)
	  (latex-mode . bibtex-completion-format-citation-cite)
	  (markdown-mode . bibtex-completion-format-citation-pandoc-citeproc)
	  (python-mode . bibtex-completion-format-citation-sphinxcontrib-bibtex)
	  (rst-mode . bibtex-completion-format-citation-sphinxcontrib-bibtex)
	  (default . bibtex-completion-format-citation-default)))

  (require 'oc)
  (require 'oc-csl)
  (setq org-cite-global-bibliography '("~/org_roam/My_Library.bib" "~/org_roam/My_Library2.bib"))

  (setq org-cite-export-processors '((t csl)))

  (setq org-cite-csl-styles-dir "~/Zotero/styles")
  (setq citeproc-org-default-style-file "~/Zotero/styles/american-chemical-society.csl")

  (require 'zotra)
  (setq zotra-backend 'zotra-server
	zotra-local-server-directory "~/Cloned_Repositories/zotra-server/"
	zotra-default-bibliography "~/org_roam/My_Library2.bib"
	zotra-download-attachment-default-directory "~/Sync/Zotero_pdfs")
#+END_SRC

** Citar
The bibliography backend I currently use is ivy-bibtex (hence the above config). However, I have experimented with Citar for porting my package ~zetteldesk-ref~ to use it as a backend besides ivy-bibtex and honestly its a pretty neat package. I am considering moving to it as its a very nice and definitely super active project. This section holds my basic configurations for it which are for now at least only defining the paths to the bibliography and notes.

#+BEGIN_SRC elisp :tangle yes

  (setq citar-bibliography '("~/org_roam/My_Library.bib" "~/org_roam/My_Library2.bib"))
  (setq citar-notes-paths '("~/org_roam/ref"))

#+END_SRC
  
** Ebib
Ebib is an emacs bibliography manager program. My customisations for it live here. The 2 functions at the end of the block are taken directly from the info page and are used to view entries that were created recently. However, a minor change is made as ~ebib--newer-than~ compares the "timestamp" entry, while my files only have the "urldate" entry for this purpose.

#+BEGIN_SRC elisp :tangle yes
  (setq ebib-preload-bib-files '("~/org_roam/My_Library.bib" "~/org_roam/My_Library2.bib"))
  (setq ebib-notes-directory "~/org_roam/ref")
  (setq ebib-multiline-major-mode 'org-mode)

  (add-hook 'ebib-entry-mode-hook 'visual-line-mode)

  (setq ebib-index-columns '(("Title" 60 t)
  			     ("Author/Editor" 40 t)
  			     ("Year" 6 t)
  			     ("Entry Key" 40 t)
  			     ("Note" 10 t)))

  (require 'org-ebib)

  (setq ebib-citation-description-function 'ebib-create-org-title)

  (defun ebib-list-recent (days)
    "List entries created in the last DAYS days."
    (interactive "nNumber of days: ")
    ;; Save the database's current filter, if there is one.
    (let ((filter (ebib-db-get-filter ebib--cur-db)))
      (when filter (setq ebib--filters-last-filter filter)))
    (let*
  	;; Calculate the from-date in Emacs' time format.
  	((date (time-subtract (current-time) (days-to-time days)))
  	 ;; Create a Lisp expression that will function as the filter.
  	 (filter `(ebib--newer-than (quote ,date))))
      ;; Install it as the current database's filter.
      (ebib-db-set-filter filter ebib--cur-db)
      ;; Update the current entry key.
      (ebib-db-set-current-entry-key (ebib--get-key-at-point) ebib--cur-db)
      ;; Update the display, so that only filtered entries are visible.
      (ebib--update-buffers)))

  (defun ebib--newer-than (date)
    "Function for use in filters.
  Return t if the entry being tested is newer than DATE.  DATE must
  be a list of the format returned by `current-time' and is
  compared to the timestamp of the entry being tested.  If the
  entry has no timestamp, or a timestamp that cannot be converted
  into a date representation, return nil."
    (let ((timestamp (cdr (assoc-string "urldate" ebib-entry))))
      (when (and timestamp
  	       (setq timestamp (ignore-errors (date-to-time timestamp))))
        (time-less-p date timestamp))))

#+END_SRC

I have also written some minor extensions for ebib, shown in this code block. They revolve around filtering org-roam functions by entries currently marked in ebib, which I personally find useful. These rely on org-roam, zetteldesk.el, my extension to org-roam for richer filtering capabilities and my custom function ~org-roam-backlinks-roam-node-read*~ which runs ~org-roam-node-read~ with a custom node list. I already use that functionality from that section of my org-roam config and I didn't want to redefine in this section with a different name, to avoid unnecessary complexity.

#+BEGIN_SRC elisp :tangle yes

  (defun org-roam-ebib-collect-marked-nodes ()
    "Collect the `org-roam-node's of all references marked in ebib.

  This function collects the citekeys of all entries that have been marked
  in ebib, a value stored in the function `ebib-db-list-marked-entries'
  and finds the `org-roam-node's related to them. As this list will be
  populated with `nil' values for any marked entry that is not related to
  an `org-roam-node' make sure to remove all `nil' values before returning
  the list. This is important if this list is to be used in other
  functions, such as `org-roam-ebib-nodes-find'."
    (cl-loop for ref in (ebib-db-list-marked-entries ebib--cur-db)
  	   collect (org-roam-node-from-ref (concat "cite:" ref)) into nodes
  	   finally return (cl-remove-if nil nodes)))

  (defun org-roam-ebib-nodes-find ()
    "Run `org-roam-node-find' for nodes marked in ebib.

  This function uses `org-roam-ebib-collect-marked-nodes' to find a list
  of `org-roam-node's that have been marked in ebib and then essentially
  runs `org-roam-node-find' for them. However, it is implemented via the
  custom function `org-roam-backlinks-roam-node-read*' from my config,
  which accepts a custom list of nodes."
    (interactive)
    (find-file (org-roam-node-file (org-roam-backlinks-roam-node-read* (org-roam-ebib-collect-marked-nodes)))))

  (defun zetteldesk-add-ebib-marked-nodes ()
    "Add nodes marked in ebib to the `zetteldesk-desktop'.

  This function collects a list of `org-roam-node's via
  `org-roam-ebib-collect-marked-nodes' and adds them to the
  `zetteldesk-desktop' using `zetteldesk-add-node-to-desktop'."
    (cl-loop for node in (org-roam-ebib-collect-marked-nodes)
  	   do (zetteldesk-add-node-to-desktop node)))

#+END_SRC

* Org Roam Bibtex, Protocols (Reference notes) and UI (graphing capabilities)
   I require a bunch of packages so ORB, org roam ui and the roam protocols work as intended. I also make orb use ivy for completions.

   For a brief description of each ones use case, org-roam-bibtex (aka ORB) is an excellent package for bibliography management inside org-roam. Since other packages help out with this, the big thing this one does is that it hooks bibtex-completion to use the org-roam ecosystem for its notes. Org-protocol is for capturing info from a web page and adding it to an org file. The org-roam-protocol is basically integrating that to the org-roam ecosystem. Org-roam-ui is the new graphing package designed for org-roam-v2. We used to use org-roam-server for this, but with the migration to v2, this package was created (which is honestly better than org-roam-server) for an excellent visual graph of your org roam directory. There are many advantages to viewing your knowledge repository with a graph so this is a must have package. 

#+BEGIN_SRC elisp :tangle yes

  (require 'org-roam-bibtex)
  (org-roam-bibtex-mode 1)

  (setq orb-insert-interface 'ivy-bibtex
	orb-note-actions-interface 'ivy)
  (setq orb-preformat-keywords '("citekey" "author" "date" "entry-type" "keywords" "url" "file"))

  (require 'org-protocol)
  (require 'org-roam-protocol)

  (require 'websocket)
  (require 'org-roam-ui)

#+END_SRC

* Export a bibtex entry to org-roam
After a discussion in the M-x research group, the idea of a way to export a bibtex entry to an org-roam file was suggested. The idea is simple. Take a bibtex entry that has the typical fields but also some fields like related papers and annotations (essentially notes on the paper) and make it into an org-roam file to leverage the database capabilities of org-roam.

It is not of need for me as I initialize literature nodes with my own template (which can be found later in this file in my templates), but I understand the value of it for someone who wants to move to org-roam and already has a large amount of bibtex entries they wish to export.

Org-roam-bibtex allows for template pre-expanding, meaning a template that expands with information taken from the bibtex file. First, we need to set the preformat keywords to include everything we may be interested in. Then, create a template that automatically finishes and inserts all the information we want. Lastly, create an interactive function that prompts for a bibtex entry and initializes a note for it with our predefined template.
 
#+BEGIN_SRC elisp

  (setq orb-preformat-keywords '("citekey" "author" "date" "entry-type" "keywords" "url" "file" "journaltitle" "note" "annote"))

  (setq bibtex-export-capture-template
	'(("b" "bibliographic entry" plain "%?" :if-new
	   (file+head "ref/${citekey}.org" "#+title: ${title}\n
  - keywords :: ${keywords}
  - tags :: ${note}

  ,* ${entry-type} by ${author} in ${journaltitle}, ${date}\n
  ${annote}")
	   :unnarowed t
	   :jump-to-captured t
	   :immediate-finish t)))

  (defun bibtex-export-org-roam (citekey)
    "Export a bibtex entry to an org-roam file.

  If called interactively, select a citekey using
  `citar-select-ref'.  Otherwise, give a citekey and with that, set
  `org-roam-capture-templates' to `bibtex-export-capture-template',
  a template specifically for this purpose and run `orb--new-note'
  on that citekey using that template."
    (interactive (list (citar-select-ref)))
    (let ((org-roam-capture-templates bibtex-export-capture-template))
      (orb--new-note citekey)))

#+END_SRC

Another potential step in this system is to create methods specializing on the org-roam-node object which get the various fields of the bibtex file. This can be done fairly easily as the snippet
#+BEGIN_SRC elisp
(bibtex-completion-get-entry (car (org-roam-node-refs (org-roam-node-at-point))))
#+END_SRC
gets an alist of all the bibtex entries. (org-roam-node-at-point is used here for simplicity of testing, in a method this would be the NODE argument). From that alist, each method could extract a different field with ~assoc~. Once we have these, we can more easily manipulate the system to display more info about each bibtex entry in an org-roam-node-find type function. It could also be used for finding similar papers (two nodes which have at least one same keyword), filter by author, year or journal and many other things.

Things to capture:
The key is already stored in ~org-roam-node-refs~. Title is the file title in any sensible template. Author, year, journal, keywords are definitely worth saving. File, url, doi etc. can be found very easily and I don't think they are worth re-saving as node metadata, as the primary goal of this is to filter based on these and display them in an org-roam-display-template and neither of those would be used there.

Abstract and the annote field used for notes can be grabbed, although probably not going to be used. And the note field with related papers could be taken, but processing it is a bit hard probably.

#+BEGIN_SRC elisp

  (cl-defmethod org-roam-node-author ((node org-roam-node))
    "Access slot \"author\" of org-roam-node struct CL-X"
    (if-let ((ref (org-roam-node-refs node))
	     (key (string-remove-prefix "cite:" (car ref)))
	     (entry (bibtex-completion-get-entry key))
	     (author (cdr (assoc "author" entry))))
	author
      ""))

  (cl-defmethod org-roam-node-journal ((node org-roam-node))
    "Access slot \"journal\" of org-roam-node struct CL-X"
    (if-let ((ref (org-roam-node-refs node))
	     (key (string-remove-prefix "cite:" (car ref)))
	     (entry (bibtex-completion-get-entry key))
	     (journal (cdr (assoc "journal" entry))))
	journal
      ""))

  (cl-defmethod org-roam-node-keywords ((node org-roam-node))
    "Access slot \"keywords\" of org-roam-node struct CL-X"
    (if-let ((ref (org-roam-node-refs node))
	     (key (string-remove-prefix "cite:" (car ref)))
	     (entry (bibtex-completion-get-entry key))
	     (keywords (cdr (assoc "keywords" entry))))
	keywords
      ""))

  (cl-defmethod org-roam-node-year ((node org-roam-node))
    "Access slot \"year\" of org-roam-node struct CL-X"
    (if-let ((ref (org-roam-node-refs node))
	     (key (string-remove-prefix "cite:" (car ref)))
	     (entry (bibtex-completion-get-entry key))
	     (year (cdr (assoc "year" entry))))
	year
      ""))

#+END_SRC

* Acting on backlinks
  Backlinks are a pivotal part of this workflow. A file has a backlink if another file links to it. As a core part of my workflow revolves around index files (or Maps of Contents) and those are files that basically everything connected to that subject links to them, they end up being files with a lot of backlinks. I have some functions here that act on backlinks which I consider useful. Excluded from this list are two defmethods I use concerning backlinks as I define all my defmethods in the first part of the config.

  The first is org-roam-node-backlinkscount, a function I initially found on the OR wiki on github, which finds the number of backlinks a note has and formats them in a nice string. Its meant to be used with org-roam-node-display-template to show the number of backlinks in the org-roam-node-UI. The second is an almost identical function, but instead of returning a formatted string it returns a number. That is meant to be used with org-roam-node-sort-by-backlinks, a function defined below which sorts nodes by the number of backlinks they have. Number comparison is much easier than comparison of string representing numbers, and due to the extra formatting applied (which I like for the purpose that function has) I couldn't find how to convert that string to a number so I just made a rewrite with that small change.

  With time, this section has gathered other very interesting subsections on playing around with a node's backlinks, so I am considering moving this section to itw own file org-roam-backlinks.el, which I might upload to github separately as it has the prospect of being a package for MELPA if its polished more and better documentation is provided.

  #+BEGIN_SRC elisp :tangle yes

    (defvar-local org-roam-backlinks-files nil
      "Buffer local variable displaying a list of the absolute paths
      of all the files that are backlinked to current node. These are
      not added by default, and as such this variable has the value
      nil but they can be added by running the
      `org-roam-backlinks-find-files' function on a node.")

    (defvar org-roam-backlinks-pdfs nil
      "After running `org-roam-export-backlinks-to-latex-pdf', to
      export a node and all its backlinks to pdf, the value of this
      variable in the original node's buffer will become a list of
      all the pdfs that were created. This is to ease the process of
      combining them as the value of this variable can then be passed
      to a program such as pdftk to combine them.")

    (defun org-roam-backlinks-sort-by-backlinks (completion-a completion-b)
      "Sorting function for org-roam that sorts the list of nodes by
    the number of backlinks. This is the sorting function in
    `org-roam-backlinks-node-find-by-backlinks'"
      (let ((node-a (cdr completion-a))
	    (node-b (cdr completion-b)))
	(>= (org-roam-node-backlinkscount-number node-a)
	    (org-roam-node-backlinkscount-number node-b))))

    (defun org-roam-backlinks-node-find-by-backlinks ()
      "Essentially works like `org-roam-node-find' (although it uses
    a combination of `find-file' and `org-roam-node-read' to
    accomplish that and not `org-roam-node-find' as only
    `org-roam-node-read' can take a sorting function as an argument)
    but the list of nodes is sorted by the number of backlinks
    instead of most recent nodes. Sorting is done with
    `org-roam-backlinks-sort-by-backlinks'"
      (interactive)
      (find-file (org-roam-node-file (org-roam-node-read nil nil #'org-roam-backlinks-sort-by-backlinks))))

    (defun org-roam-backlinks-query ()
      "Simple org-roam query function that stores the IDs of all the
      files that link to the node at point. This is a modified part
      of the `org-roam-backlinks-get' function keeping only the part
      necessary for `org-roam-backlinks-find-files' to work as this is a
      complimentary function to that"
      (org-roam-db-query
       [:select [source dest]
		:from links
		:where (= dest $s1)
		:and (= type "id")]
       (org-roam-node-id (org-roam-node-at-point))))

    (defun org-roam-backlinks-find-files ()
	"Get all nodes that link to the node at point with the
	`org-roam-backlink-query' function, find their absolute path
	and save a list of those paths to the buffer local variable
	`org-roam-backlinks'.

      With the list, you can act on all those files together. This is
      exceptionally useful with index files as it allows you to do an
      action on all files linked to this index automatically."
	(interactive)
	(let ((backlinks (length (org-roam-backlinks-query))))
	  (dotimes (number backlinks)
	    (let* ((id (car (nth number (org-roam-backlinks-query))))
		   (node (org-roam-node-from-id id)))
	      (setq-local org-roam-backlinks-files (cons (org-roam-node-file node) org-roam-backlinks-files))))
	  org-roam-backlinks-files))

    (defun org-roam-backlinks-export-to-latex-pdf ()
      "Export the current buffer and every buffer that mentions it to
    a pdf through the org-latex export. Makes use of the
    `org-roam-backlinks-find-files' function to find all the
    backlinks. Also saves all the pdf names in a variable called
    `org-roam-backlinks-pdfs'. These names can then be passed to
    something like pdftk to merge them into one pdf"
      (interactive)
      (save-current-buffer
	(let ((backlinks (cons (buffer-file-name) org-roam-backlinks-files))
	      (org-startup-with-latex-preview nil))
	  (while backlinks
	    (find-file (car backlinks))
	    (org-latex-export-to-pdf)
	    (setq org-roam-backlinks-pdfs
		  (cons (concat (file-name-sans-extension (car backlinks)) ".pdf") org-roam-backlinks-pdfs))
	    (setq backlinks (cdr backlinks)))))
      (message "%s" "Done!"))

  #+END_SRC

** Org-roam-backlinks-search
This section is about a small "package" I recently wrote. Its a backlink selector functionality for org-roam. I thought it was a neat idea to be able to navigate from one node to its backlinks and repeat recursively so I wrote this code for it. Once I polish it further, I might release some of this to MELPA. For now it will stay here.

#+BEGIN_SRC elisp :tangle yes

  (defcustom org-roam-backlinks-choices '("View Backlinks" "Go to Node" "Add to Zetteldesk" "Find Similar Nodes" "Quit")
    "List of choices for `org-roam-backlinks-node-read'.
  Check that function's docstring for more info about these.")

  (defun org-roam-backlinks-query* (NODE)
    "Gets the backlinks of NODE with `org-roam-db-query'."
    (org-roam-db-query
	  [:select [source dest]
		   :from links
		   :where (= dest $s1)
		   :and (= type "id")]
	  (org-roam-node-id NODE)))

  (defun org-roam-backlinks-p (SOURCE NODE)
    "Predicate function that checks if NODE is a backlink of SOURCE."
    (let* ((source-id (org-roam-node-id SOURCE))
	   (backlinks (org-roam-backlinks-query* SOURCE))
	   (id (org-roam-node-id NODE))
	   (id-list (list id source-id)))
      (member id-list backlinks)))

  (defun org-roam-backlinks-poi-or-moc-p (NODE)
    "Check if NODE has the tag POI or the tag MOC.  Return t if it does."
    (or (string-equal (car (org-roam-node-tags NODE)) "POI")
	(string-equal (car (org-roam-node-tags NODE)) "MOC")))

  (defun org-roam-backlinks--read-node-backlinks (source)
    "Runs `org-roam-node-read' on the backlinks of SOURCE.
  The predicate used as `org-roam-node-read''s filter-fn is
  `org-roam-backlinks-p'."
    (org-roam-node-read nil (apply-partially #'org-roam-backlinks-p source)))

  (defun org-roam-backlinks-node-read (node)
    "Read a NODE and run `org-roam-backlinks--read-node-backlinks'.
  Upon selecting a backlink, prompt the user for what to do with
  the backlink. The prompt is created with `completing-read' with
  valid options being everything in the list
  `org-roam-backlinks-choices'.

  If the user decides to view the selected node's backlinks, the
  function recursively runs itself with the selection as its
  argument. If they decide they want to go to the selected node,
  the function runs `find-file' and the file associated to that
  node. Lastly, if they choose to quit, the function exits
  silently.

  There is however also the option to add the node to the current
  `zetteldesk-desktop'. `zetteldesk.el' is a package I have written
  to extend org-roam and naturally I wanted to include some
  interaction with it in this function."
    (let* ((backlink (org-roam-backlinks--read-node-backlinks node))
	   (choice (completing-read "What to do with NODE: "
				    org-roam-backlinks-choices)))
      (cond
       ((string-equal
	 choice
	 (first org-roam-backlinks-choices))
	(org-roam-backlinks-node-read backlink))
       ((string-equal
	 choice
	 (second org-roam-backlinks-choices))
	(find-file (org-roam-node-file backlink)))
       ((string-equal
	 choice
	 (third org-roam-backlinks-choices))
	(zetteldesk-add-node-to-desktop backlink))
       ((string-equal
	 choice
	 (fourth org-roam-backlinks-choices))
	(org-roam-similarity-node-find backlink))
       ((string-equal
	 choice
	 (fifth org-roam-backlinks-choices))))))

  (defun org-roam-backlinks-search ()
    "Select an `org-roam-node' and recursively search its backlinks.

  This function is a starter function for
  `org-roam-backlinks-node-read' which gets the initial node
  selection from `org-roam-node-list'. For more information about
  this function, check `org-roam-backlinks-node-read'."
    (interactive)
    (let ((node (org-roam-node-read)))
      (org-roam-backlinks-node-read node)))

  (defun org-roam-backlinks-search-from-moc-or-poi ()
    "`org-roam-backlinks-search' with an initial selection filter.

  Since nodes tagged as \"MOC\" or \"POI\" are the entry points to
  my personal zettelkasten, I have this helper function which is
  identical to `org-roam-backlinks-search' but filters initial
  selection to only those notes. That way, they initial selection
  has a point as it will be on a node that has a decent amount of
  backlinks."
    (interactive)
    (let ((node (org-roam-node-read nil #'org-roam-backlinks-poi-or-moc-p)))
      (org-roam-backlinks-node-read node)))

#+END_SRC

#+RESULTS:
: org-roam-backlinks-search-from-moc-or-poi
  
** Find intersecting backlinks of multiple nodes
This section is about a [[https://org-roam.discourse.group/t/group-links-tags-in-org-roam/2871/11][discussion]] I recently had in the Org-Roam Discourse. I mentioned that I have made a recursive backlinks searcher for org-roam nodes (which is in the above section) and I was asked if I could expand this sort of idea and make a function that finds the backlinks of a number of different nodes. There will be two major parts to this section. The first, is collecting the list of nodes which are backlinked to a number of nodes selected by the user and the second is displaying this list to the user, allowing them to select one and doing something with that.

*** Collect the list of nodes
First, we need to prompt the user to select the nodes they want.

#+BEGIN_SRC elisp :tangle yes

  (defvar org-roam-backlinks-selected-nodes '()
    "List of nodes selected in `org-roam-backlinks--select-nodes'.")

  (defun org-roam-backlinks--select-nodes (NUM)
    "Select NUM `org-org-roam-nodes' and return a list of those."
    (setq org-roam-backlinks-selected-nodes '())
    (dotimes (i NUM)
      (let ((node (org-roam-node-read)))
	(add-to-list 'org-roam-backlinks-selected-nodes node)))
    org-roam-backlinks-selected-nodes)
  
#+END_SRC

Then, get a list of lists containing all their backlinks.

#+BEGIN_SRC elisp :tangle yes

  (defvar org-roam-backlinks-selected-node-backlinks '()
    "List of backlinks of nodes in `org-roam-backlinks-selected-nodes'.

  This list is filled using `org-roam-backlinks-get-node-backlinks'")

  (defun org-roam-backlinks-get-node-backlinks (NUM)
    "Get a list of lists of backlinks of the nodes in NODE-LIST."
    (setq org-roam-backlinks-selected-node-backlinks '())
    (let ((node-list (org-roam-backlinks--select-nodes NUM)))
      (dolist (node node-list)
	(let ((backlinks (org-roam-backlinks-query* node))
	      (backlink-ids))
	  (dolist (id backlinks)
	    (add-to-list 'backlink-ids (car id)))
	  (add-to-list 'org-roam-backlinks-selected-node-backlinks backlink-ids)))
      org-roam-backlinks-selected-node-backlinks))

#+END_SRC

And then, take these lists and find their intersection.

#+BEGIN_SRC elisp :tangle yes

  (defun org-roam-backlinks-id-intersection (list1 list2)
    "Find intersection of LIST1 and LIST2 using `cl-loop'."
    (cl-loop for id in list1
	     if (member id list2)
	     collect id into ids
	     finally (return ids)))

  (defun org-roam-backlinks-get-ids (NUM)
    "Get the ids of all nodes which are backlinks of the selected nodes.

  Node selection is done with the underlying function
  `org-roam-backlinks--select-nodes'."
    (let* ((backlink-ids (org-roam-backlinks-get-node-backlinks NUM))
	   (result (car backlink-ids)))
      (dolist (ids backlink-ids)
	(setq result (org-roam-backlinks-id-intersection result ids)))
      result))

#+END_SRC

The end result is that calling ~org-roam-backlinks-get-ids~ will call all the necessary functions. This includes prompting for NUM org-roam-nodes, finding each ones backlinks and their intersection. It returns a list of ids, which can then be passed to the functions of the other section. None of these are interactive as they are the backbone of the setup.

*** Modifying org-roam-node-read to accept a list of nodes
Since we have collected a list of nodes (in the form of their ids) that can not be reproduced with a simple predicate, we need to make a version of ~org-roam-node-read~ which can take this list as an argument. Luckily for me, I have already encountered this problem before in zetteldesk so I have the code ready. Changing them to start with org-roam-backlinks instead of zetteldesk-ref, we get these.

#+BEGIN_SRC elisp :tangle yes

  (defun org-roam-backlinks-roam-node-read--completions* (node-list &optional filter-fn sort-fn)
    "Run `org-roam-node-read--completions' with NODE-LIST being a list of nodes.

  Typically, the function takes `org-roam-node-list' as the initial
  list of nodes and creates the alist `org-roam-node-read'
  uses.  However, it can be helpful to supply the list of nodes
  yourself, when the predicate function used cannot be inferred
  through a filter function of the form this function
  takes.  FILTER-FN and SORT-FN are the same as in
  `org-roam-node-read--completions'.  The resulting alist is to be
  used with `org-roam-backlinks-roam-node-read*'."
    (let* ((template (org-roam-node--process-display-format org-roam-node-display-template))
	   (nodes node-list)
	   (nodes (mapcar (lambda (node)
			    (org-roam-node-read--to-candidate node template)) nodes))
	   (nodes (if filter-fn
		      (cl-remove-if-not
		       (lambda (n) (funcall filter-fn (cdr n)))
		       nodes)
		    nodes))
	   (sort-fn (or sort-fn
			(when org-roam-node-default-sort
			  (intern (concat "org-roam-node-read-sort-by-"
					  (symbol-name org-roam-node-default-sort))))))
	   (nodes (if sort-fn (seq-sort sort-fn nodes)
		    nodes)))
      nodes))

  (defun org-roam-backlinks-roam-node-read* (node-list &optional initial-input filter-fn sort-fn require-match prompt)
    "Run `org-roam-node-read' with the nodes supplied by NODE-LIST.

  NODE-LIST is a list of nodes passed to
  `org-roam-backlinks-roam-node-read--completions*', which creates an alist of
  nodes with the proper formatting to be used in this
  function.  This is for those cases where it is helpful to use your
  own list of nodes, because a predicate function can not filter
  them in the way you want easily.

  INITIAL-INPUT, SORT-FN, FILTER-FN, REQUIRE-MATCH, PROMPT are the
  same as in `org-roam-node-read'."
    (let* ((nodes (org-roam-backlinks-roam-node-read--completions* node-list filter-fn sort-fn))
	   (prompt (or prompt "Node: "))
	   (node (completing-read
		  prompt
		  (lambda (string pred action)
		    (if (eq action 'metadata)
			`(metadata
			  ;; Preserve sorting in the completion UI if a sort-fn is used
			  ,@(when sort-fn
			      '((display-sort-function . identity)
				(cycle-sort-function . identity)))
			  (annotation-function
			   . ,(lambda (title)
				(funcall org-roam-node-annotation-function
					 (get-text-property 0 'node title))))
			  (category . org-roam-node))
		      (complete-with-action action nodes string pred)))
		  nil require-match initial-input 'org-roam-node-history)))
      (or (cdr (assoc node nodes))
	  (org-roam-node-create :title node))))

#+END_SRC

*** Interactive functions and user interface
Finally, we are down to the easiest part. Having written the backbone of the process, we need to allow the user to select a single node from the possible choices in an interactive way and then write the end user functions which take this node and do things with it. For now, I will implement an ~org-roam-node-find~ style function and a connection to the above section to kickstart ~org-roam-backlinks-node-read~ with this instead of what ~org-roam-backlinks-search~ does. These functions are shown below

#+BEGIN_SRC elisp :tangle yes

  (defun org-roam-backlinks-multi-node-read ()
    "Read a node from intersecting backlinks of multiple nodes.

  This is the low-level interactive function which is used for
  collecting the nodes which are backlinks to a number of selected
  nodes. This function calls `org-roam-backlinks-get-ids' for a lot
  of the work, which returns a list of ids of all nodes which are
  backlinked to some selected nodes. For more, check its
  docstring. With this list of ids, this function runs
  `org-roam-backlinks-roam-node-read*', which is a modified
  `org-roam-node-read' which accepts a list of nodes as its
  argument. This function returns the selected node to be used in
  the higher level functions."
    (interactive)
    (let* ((num (read-number "Number of Nodes: "))
	   (ids (org-roam-backlinks-get-ids num))
	   (nodes (cl-loop for id in ids
			   collect (org-roam-node-from-id id) into nodes
			   finally (return nodes))))
      (org-roam-backlinks-roam-node-read* nodes)))

  (defun org-roam-backlinks-multi-node-find ()
    "Find node from intersecting backlinks of multiple nodes.

  This is a wrapper function for
  `org-roam-backlinks-multi-node-read', which finds the file
  associated with the selected node instead of returning it."
    (interactive)
    (let ((node (org-roam-backlinks-multi-node-read)))
      (find-file (org-roam-node-file node))))

  (defun org-roam-backlinks-multi-search ()
    "Select an `org-roam-node' and recursively search its backlinks.

  This function is an extension of the `org-roam-backlinks-search'
  function which is used for recursively searching a node's
  backlinks using `org-roam-backlinks-node-read'. Its main
  difference is that it kickstarts the system not by selecting a
  node but by running `org-roam-backlinks-multi-node-read'.  This
  means that the selected node will be the intersection of
  backlinks of a number of nodes selected from that function."
    (interactive)
    (let ((node (org-roam-backlinks-multi-node-read)))
      (org-roam-backlinks-node-read node)))

#+END_SRC

* Logseq-like tagging functionality
  I recently had a [[https://www.reddit.com/r/orgmode/comments/tgb7f9/orgroam_journey/i17ohct/?context=3][discussion]] with a fellow redditor on r/orgmode about how to get some useful features logseq has in org-roam. Especially, he told me how logseq handles tags and some useful features they have. Intrigued by the idea, I decided I could try and implement it to org-roam as a fun little project. It didn't sound so hard so I was like, sure why not. Here's the result I got. I don't even know if I am going to use this, but it can stay here for now. Note that it relies on org-transclusion to do a lot of the work. 

  #+BEGIN_SRC elisp :tangle zettelkasten.el

    (defun org-roam-node-sort-by-atime (NODE1 NODE2)
      "Sorting function that sorts NODE1 and NODE2 by their file atime.

    This is a simplified version of
    `org-roam-node-read-sort-by-file-atime' which requires nodes as
    its input and not something else. The above function is what
    `org-roam-node-read's sorting uses and it has a special
    formatting."
      (time-less-p (org-roam-node-file-atime NODE1)
		   (org-roam-node-file-atime NODE2)))

    (defun org-roam-logseq-tag-function (TAG)
      "An implementation of logseq's tagging system in org-roam.

    Prompt for TAG which is the name of a tag in your org-roam
    repository, filter it to only contain nodes with that tag and
    sort them so the most recently accessed one is the first item of
    the list. Sorting is done with the custom
    `org-roam-node-sort-by-atime' function. Then, check if a buffer
    exists with the name *TAG-nodes* and if it doesn't create it.

    In that new buffer, switch to org-mode and for every item in the
    sorted-nodes list, go to `point-max', insert a new line, insert
    the string #+transclude: make an org-mode id link with the node's
    id and insert another newline. Once done, run
    `org-transclusion-add-all' to activate the transclusion links and
    view editable versions of the selected nodes.

    Finally, restore the buffer from which this function was called
    and insert and org-mode elisp link that runs `switch-to-buffer'
    to switch to the newly-created buffer."
      (interactive "MTag: ")
      (let* ((init-list (org-roam-node-list))
	     (tagged-nodes (cl-remove-if-not (lambda (NODE)
					       (member TAG (org-roam-node-tags NODE)))
					     init-list))
	     (sorted-nodes (reverse (sort tagged-nodes #'org-roam-node-sort-by-atime)))
	     (buffer-name (concat "*" TAG "-nodes*"))
	     (buffer (get-buffer-create buffer-name)))
	(save-excursion
	  (with-current-buffer buffer
	    (org-mode)
	    (dolist (node sorted-nodes)
	      (goto-char (point-max))
	      (newline)
	      (insert
	       "#+transclude: "
	       (org-link-make-string
		(concat "id:" (org-roam-node-id node))))
	       (newline))
	    (org-transclusion-add-all)))
	(insert
	 (org-link-make-string
	  (concat "elisp:(switch-to-buffer \"" buffer-name "\")")
	  (concat "#" TAG)))))

  #+END_SRC

* Org-similarity
Org-similarity is a package to be used with org-roam for discovering documents similar to the current buffer. I discovered it from [[https://org-roam.discourse.group/t/a-demo-of-ai-for-linking-writing-and-thinking-with-org-roam-should-we-build-org-roam-ai/2891/3][this]] discussion in the Org-Roam Discourse group. The first code block is setting various configuration variables. Then will be config I have added myself.

#+BEGIN_SRC elisp :tangle yes

  (require 'org-similarity)

  ;; Directory to scan for possibly similar documents.
  ;; org-roam users might want to change it to `org-roam-directory'.
  (setq org-similarity-directory org-roam-directory)

  ;; How many similar entries to list at the end of the buffer.
  (setq org-similarity-number-of-documents 10)

  ;; Whether to prepend the list entries with similarity scores.
  (setq org-similarity-show-scores nil)

  ;; Similarity score threshold. All results with a similarity score below this
  ;; value will be omitted from the final list.
  ;; Default is 0.05.
  (setq org-similarity-threshold 0.05)

  ;; Whether the resulting list of similar documents will point to ID property or
  ;; filename. Default is nil.
  ;; However, I recommend setting it to `t' if you use `org-roam' v2.
  (setq org-similarity-use-id-links t)

  ;; Scan for files inside `org-similarity-directory' recursively.
  (setq org-similarity-recursive-search t)

  ;; Remove first result from the scores list. Useful if the current buffer is
  ;; saved in the searched directory, and you don't want to see it included
  ;; in the list. Default is nil."
  (setq org-similarity-remove-first nil)

  ;; Text to show in the list heading. You can set it to "" if you
  ;; wish to hide the heading altogether.
  (setq org-similarity-heading "** Related notes")

  ;; String to prepend the list items. You can set it to "* " to turn each
  ;; item into org headings, or "- " to turn them into an unordered org list.
  ;; Set the variable to "" to hide prefixes.
  (setq org-similarity-prefix "- ")
#+END_SRC

#+RESULTS:
: - 

* Fleeting notes
   This is one of the more interesting sections of my workflow as its really custom and from what I have seen really unique. The zettelkasten method has a concept of fleeting notes. They are small notes which should be easy and non intrusive to write quickly to capture ideas and need to be archived when done. I "abuse" the todo-keywords org provides for this to completely repurpose them into what I need. As mentioned above, my org-roam-node-find UI shows the todo state of files which have one. 

Now which files have a todo state? Since org-roam-v2, headings can have IDs and can become nodes. Headings can also have a todo state. The todo states I use are helpful for me for a lot purposes. Inbox, Processing, To-Read and Wait show in which level of editing something is while Urgent is there for things I need to get to ASAP and Low-Priority is for things I want to remember but I can do them whenever. This gives me a lot of flexibility in my daily (fleeting) notes as I can define all of these and then search my zettelkasten for things with this keyword. But, headings have neither an ID nor a todo state in their creation. So I created a function which gives these to a new heading. Together with these, it links the fleeting note to a file named Current Projects, which acts as an index for my fleeting notes so they are not fully disconnected from the system and I have another way of viewing all of them together. To add the link without a prompt (such as that of org-roam-node-insert) I use a skeleton which adds an ID link to that file. 

Lastly, for this system to work properly for fleeting notes I need a seamless way of archiving my daily notes once I am done with the idea they store. For that, we need to define a function which deleted the ID of a node. But running that manually is by no means seamless and in my opinion unacceptable. An idea I found which works perfectly for this is the last code snippet in this section. Essentially, it adds to the org-after-todo-state-change-hook a check of what the new keyword is. If it is DONE, it runs org-id-delete-entry, deleting the ID. Therefore, whenever I set the item's state to done, it removes its ID archiving it from the system. But the file is never deleted, so if I want the context again, I can look for it in the daily directory. But, if I were to do this with the org-roam-dailies package I would reach a big problem. As the file itself gets an ID but not a todo state, it would have an ID which isn't removable automatically, something which would as mentioned above break the system in my opinion. So, these files are created with org-journal so that I can give IDs only to the headings. There isn't much configuration on that end, just some different formatting to a format I think makes more sense. 
   
#+BEGIN_SRC elisp :tangle yes

  (setq org-todo-keywords
	'((sequence "INBOX(i)"
		    "PROCESSING(p)"
		    "URGENT(u)"
		    "LOW-PRIORITY(l)"
		    "WAIT(w)"
		    "TO-READ(r)"
		    "|"
		    "DONE(d)"
		    )))

  (setq org-agenda-files
	'("~/org_roam"
	  "~/org_roam/daily"
	  "~/org_roam/ref"))

  (setq org-journal-dir "~/org_roam/daily"
	org-journal-file-format "%d-%m-%Y.org"
	org-journal-time-format "%a, %d/%m-%R")

  (add-hook 'org-agenda-mode-hook 'visual-line-mode)

  (define-skeleton project-skeleton
    "This skeleton inserts a link to the Current Projects file in the org-roam directory. 

  Its used in my fleeting note initialization function as a means
  to always make new fleeting notes point to the current projects
  file, as that is that files purpose"
    ""
    "- tags :: [[id:b5e71fe5-9d76-4f7f-b58d-df6a561e6a6b][Current Projects]]")

  (defun org-roam-init-fleeting-note ()
    "Prescribe an ID to the heading making it a node in org-roam, then
    add it the inbox by giving it a todo keyword. Finally, insert a new
    line and the `project-skeleton', linking the new file to the Current
    Projects file.

   This helps automate the process of creating new fleeting notes
   in combination with the `org-journal' commands"
    (interactive)
    (org-id-get-create)
    (evil-open-below 1)
    (project-skeleton)
    (org-todo))

  (defun org-id-delete-entry ()
  "Remove/delete an ID entry. Saves the current point and only does this if inside an org-heading."
  (interactive)
    (save-excursion
      (org-back-to-heading t)
      (when (org-entry-delete (point) "ID"))))

  (add-to-list 'org-after-todo-state-change-hook
	       (lambda ()
		 (when (equal org-state "DONE")
		   (org-id-delete-entry))))

  (defun org-roam-node-find-todos ()
    "Filtered view of org-roam-node-find which displays only nodes
  with a todo state. All my fleeting notes typically have a todo
  state indicating I need to work on them so this filter helps me
  out"
    (interactive)
    (org-roam-node-find nil nil #'org-roam-node-todo))

#+END_SRC


* Capture Templates
   Capture templates are really the "heart" of my zettelkasten workflow. By having a prefefined form for all files I create with the system I do not lose time trying to get a standard format on them. Its very important therefore to have at least a well customised default template. The rest of my templates here are for the capturing of specific things. Mine isn't that special but it has some important things.

   The outline capture template is part of the workflow I have crafted with the functions of the zetteldesk (see below). Essentially they are used for outlining a subject during revision and are files that are densely linked with everything that has to do with the subject. After done, they are archived (meaning I remove their ID) as they annoy me in org-roam-node-find and org-roam-ui. I have a shortcut to jump to the directory in which they are located so I do not really fear losing them. One might ask why make them through org roam in the first place if I am going to remove their ID. Well the answer is simple. Its easier this way. While working on it, I want it to be a node so I can find it faster with org-roam commands. But when done, its not actually useful info to keep, so I archive it, but its stored in its own directory so I can find it if I need it again. 

   Then the other 2 templates I define are used for bibliographic information. Basic part of these is that they are stored in a subdirectory of the org_roam folder named ref and have tags depending on what type of file they are. For example, all articles I have have a tag article, and books have a tag book. The bibliography reference template is for things stored in my .bib file. This is mostly things like scientific articles. This is a very neat template as it uses a lot of the information the bibliography file has to make the template really functional. My favourite part of it is that if the entry has a pdf file attached to it, it will automatically set up org-noter to work with that file. The other template I use (info reference) is for creating reference notes from emacs info buffers. org-roam-capture-templates holds some special values if it is invoked in some special buffers one of which is the info-buffer. Specifically, it stores that the capture process was started in an info buffer, which file the buffer was visiting and which node it was in. With this info (no pun intended) and some elisp magic, you can automatically create a link that points to the info buffer the capture was invoked from so you have a reference point when you look at the note again. I found this a very cool feature of org-roam-capture-templates so I integrated it in a template. 

   Also part of my templates I use for bibliographic information, is the org-roam-capture-ref-templates variable. This one is invoked when one captures a web page using org-roam-protocol. Besides books, articles, info pages and whatever else the above 2 cover, capturing info from a web page, is very important to my workflow. So I need to have a good template for it. Its not much, but its important. Org-roam-protocol doesn't store much special info besides the title of the web page so this template is about as simple as my default one. 

   Lastly, I define the org-roam-dailies-capture-templates. As discussed above I do not use these too much, but since I have tried them I have kept the template I made for them. Its got the same formatting as the org-journal ones so if a file is created with one method the other can add things to it.

   #+BEGIN_SRC elisp :tangle yes

     (setq org-roam-capture-templates
	   '(("d" "default" plain "%?" :if-new
	      (file+head "${slug}-%<%d-%m-%y>.org" "#+title: ${title}
     - index ::  
     - tags :: ")
	      :unnarrowed t
	      :jump-to-captured t)

	     ("o" "outline" plain "%?" :if-new
	      (file+head "outlines/${slug}-%<%d-%m-%y>.org" "#+title: ${title}
     ,#+filetags: outline")
	      :unnarrowed t
	      :jump-to-captured t)

	     ("r" "bibliography reference" plain
	      "%?"
	      :if-new
	      (file+head "ref/${citekey}.org" "#+title: ${title}\n
     ,#+filetags: ${entry-type}
     - keywords :: ${keywords}
     - tags :: 

     ,* Analysis of ${entry-type} by ${author}
     :PROPERTIES:
     :URL: ${url}
     :NOTER_DOCUMENT: ${file}  
     :NOTER_PAGE:              
     :END:")
	      :unnarrowed t
	      :jump-to-captured t)

	     ("i" "info reference" plain
	      "%?"
	      :if-new
	      (file+head "ref/${slug}.org" "#+title: ${title}\n
     ,#+filetags: %:type
     - tags :: \n

     [[elisp:(Info-goto-node \"(%:file)%:node\")][Link to Info page]]
	  \n
	  ")
	      :unnarowed t)

	     ("e" "elfeed" plain
	      "%?"
	      :if-new
	      (file+head "ref/${slug}.org" "#+title: %:description\n
     ,#+filetags: %:type
     - keywords ::
     - tags :: \n\n\n

     [[%:link][Link to Elfeed Buffer]]
     [[%:elfeed-entry-link][Link to Web Page]]")
	      :unnarowed t)

	     ("t" "thesis" plain "%?" :if-new
	      (file+head "thesis/${slug}-%<%d-%m-%y>.org" "#+title: ${title}
     - index ::  
     - tags :: ")
	      :unnarrowed t
	      :jump-to-captured t)))

     (setq org-roam-capture-ref-templates 
	   '(("r" "ref" entry "* %?" :target
	      (file+head "ref/${slug}.org" "#+title: ${title}\n
	  ,#+filetags: 
	   - tags :: \n")
	      :unnarrowed t
	      :jump-to-captured t)))

     (setq org-roam-dailies-capture-templates
	   '(("d" "default" entry "* %?" :if-new
	      (file+head "%<%Y-%m-%d>.org" "#+title: %<%Y-%m-%d>\n#+filetags: daily")
	      :empty-lines 1)))

   #+END_SRC

   #+RESULTS:
   | d | default | entry | * %? | :if-new | (file+head %<%Y-%m-%d>.org #+title: %<%Y-%m-%d> |

* Providing the packages to be loaded in init.el
  #+BEGIN_SRC elisp :tangle yes

    (provide 'zettelkasten)

  #+END_SRC
  
