#+TITLE: Org-Roam, References and the Zettelkasten Workflow

This file is a core part of my emacs configuration and is all about my Org-roam setup and my reference management inside org. Its based on the Zettelkasten method and the Roam Research website. Notes are linked with one another. Bibtex completion (and the existence of .bib files in general) as well as Org-ref help manage bibliographic references inside org. I also use Zotero as it easily allows me to gather my bibliographies. It exports a .bib file which these two use. Org Roam Bibtex (ORB) is a package that combines all of these to help you add citation links from org-ref inside an org-roam buffer. This section includes all the customisations and settings of these packages. This is a very large section of my config (hence why it has its own file) as I have really customised this workflow a lot. 

* Org-Roam general setup
  This part is the general setup of org-roam. It contains the setup, removing the warning message for the migration to v2, and the use-package declaration for org-roam. There I put the org roam directory, the various defmethods I use, my display template and a resize to the org-roam buffer as taking half the screen isn't something I like. I much prefer it to be a bit smaller than the main window.

  A lot of the defmethods defined here are for my display template as I think its useful to see directories, backlink count and todo state of nodes in the org-roam-node-find UI. Then there is the oddball org-roam-node-backlinkscount-number which is identical almosy to org-roam-node-backlinkscount, but its different output is useful for a function I define later and the org-roam-node-buffer defmethod which is a very helpful defmethod that imo should have been defined in org-roam. It returns the buffer associated to a node, and nil if there is none. I use this in various parts of my config and I consider it an important defmethod. 
   
 #+BEGIN_SRC elisp :tangle yes

   (add-hook 'after-init-hook 'org-roam-setup)
   (setq org-roam-v2-ack t)

   (use-package org-roam
     :config
     (setq org-roam-directory "~/org_roam"
	   org-roam-dailies-directory "~/org_roam/daily")

     (cl-defmethod org-roam-node-directories ((node org-roam-node))
       "Access slot \"directory\" of org-roam-node struct CL-X"
       (if-let ((dirs (file-name-directory (file-relative-name (org-roam-node-file node) org-roam-directory))))
	   (format "(%s)" (car (f-split dirs)))
	 ""))

     (cl-defmethod org-roam-node-backlinkscount ((node org-roam-node))
       "Access slot \"backlinks\" of org-roam-node struct CL-X"
       (let* ((count (caar (org-roam-db-query
			    [:select (funcall count source)
				     :from links
				     :where (= dest $s1)
				     :and (= type "id")]
			    (org-roam-node-id node)))))
	 (format "[%d]" count)))

     (cl-defmethod org-roam-node-backlinkscount-number ((node org-roam-node))
       "Access slot \"backlinks\" of org-roam-node struct CL-X. This is identical to `org-roam-node-backlinkscount' with the difference that it returns a number instead of a fromatted string. This is to be used in `org-roam-node-sort-by-backlinks'"
       (let* ((count (caar (org-roam-db-query
			    [:select (funcall count source)
				     :from links
				     :where (= dest $s1)
				     :and (= type "id")]
			    (org-roam-node-id node)))))
	 count))

     (cl-defmethod org-roam-node-todostate ((node org-roam-node))
       "Modified version of org-roam-node-todo to look a bit better"
       (if-let ((state (org-roam-node-todo node)))
	   (format "Status: %s" state)))

     (cl-defmethod org-roam-node-buffer ((node org-roam-node))
       "Access slot \"buffer\" of org-roam-node struct CL-X"
       (let ((buffer (get-file-buffer (org-roam-node-file node))))
	 buffer))

     (setq org-roam-node-display-template "${title:100} ${backlinkscount:6} ${todostate:20} ${directories:8} ${tags:25}")

     (add-to-list 'display-buffer-alist
		  '("\\*org-roam\\*"
		    (display-buffer-in-direction)
		    (direction . right)
		    (window-width . 0.40)
		    (window-height . fit-window-to-buffer))))

   #+END_SRC

* Useful Functions
   Org roam is a cornerstone of my workflow (which is the reason this file is so stupidly large). I have written various "helper" functions for my own assistance that are meant to be used with org-roam. This section includes those functions. They are all documented well so I do not think I need to describe them. 

#+BEGIN_SRC elisp :tangle yes

  (defun org-roam-buffer-without-latex ()
      "Essentially `org-roam-buffer-toggle' but it ensures latex previews are turned off before toggling the buffer.

    This is useful because especially with index files, having latex
    previews on, makes opening the buffer very slow as it needs to load
    previews of many files. If you by default have
    `org-startup-with-latex-preview' set to t, you have probably noticed
    this issue before. This function solves it."
      (interactive)
      (let ((org-startup-with-latex-preview nil))
	(org-roam-buffer-toggle)))

  (defun org-roam-permanent-note-p (NODE)
    "Check if NODE is at the top level org_roam directory using the `org-roam-node-directories' function. If it isn't, `org-roam-node-directories' will return a non empty string, therefore this expression will evaluate to nil. The way my notes are sorted, when a note is placed on the top level its a permanent note, while fleeting and reference notes are placed in subdirectories. 

  Therefore, this predicate function allows me to create a version of `org-roam-node-find' which only shows my permanent notes, which can be useful in some cases. That filtered function is `org-roam-find-permanent-node'."
    (string-equal (org-roam-node-directories NODE) ""))

  (defun org-roam-find-permanent-node ()
    "Execute `org-roam-node-find' with the list being filtered to only include permanent notes. In my system that is synonymous to saying include only notes at the top level directory. The filtering is done with the `org-roam-permanent-note-p' predicate function."
    (interactive)
    (org-roam-node-find nil nil #'org-roam-permanent-note-p))
#+END_SRC

* Acting on backlinks
  Backlinks are a pivotal part of this workflow. A file has a backlink if another file links to it. As a core part of my workflow revolves around index files (or Maps of Contents) and those are files that basically everything connected to that subject links to them, they end up being files with a lot of backlinks. I have some functions here that act on backlinks which I consider useful. Excluded from this list are two defmethods I use concerning backlinks as I define all my defmethods in the first part of the config.

  The first is org-roam-node-backlinkscount, a function I initially found on the OR wiki on github, which finds the number of backlinks a note has and formats them in a nice string. Its meant to be used with org-roam-node-display-template to show the number of backlinks in the org-roam-node-UI. The second is an almost identical function, but instead of returning a formatted string it returns a number. That is meant to be used with org-roam-node-sort-by-backlinks, a function defined below which sorts nodes by the number of backlinks they have. Number comparison is much easier than comparison of string representing numbers, and due to the extra formatting applied (which I like for the purpose that function has) I couldn't find how to convert that string to a number so I just made a rewrite with that small change.  

  #+BEGIN_SRC elisp :tangle yes

    (defvar-local org-roam-backlinks nil
      "Buffer local variable displaying a list of the absolute paths of all the files that are backlinked to current node. These are not added by default, and as such this variable has the value nil but they can be added by running the `org-roam-backlink-files' function on a node.")

    (defvar-local org-roam-backlink-pdfs nil
      "After running `org-roam-export-backlinks-to-latex-pdf', to export a node and all its backlinks to pdf, the value of this variable in the original node's buffer will become a list of all the pdfs that were created. This is to ease the process of combining them as the value of this variable can then be passed to a program such as pdftk to combine them.")

    (defun org-roam-node-sort-by-backlinks (completion-a completion-b)
      "Sorting function for org-roam that sorts the list of nodes by the number of backlinks. This is the sorting function in `org-roam-node-find-by-backlinks'"
      (let ((node-a (cdr completion-a))
	    (node-b (cdr completion-b)))
	(>= (org-roam-node-backlinkscount-number node-a)
	    (org-roam-node-backlinkscount-number node-b))))

    (defun org-roam-node-find-by-backlinks ()
      "Essentially works like `org-roam-node-find' (although it uses a combination of `find-file' and `org-roam-node-read' to accomplish that and not `org-roam-node-find' as only `org-roam-node-read' can take a sorting function as an argument) but the list of nodes is sorted by the number of backlinks instead of most recent nodes. Sorting is done with `org-roam-node-sort-by-backlinks'"
      (interactive)
      (find-file (org-roam-node-file (org-roam-node-read nil nil #'org-roam-node-sort-by-backlinks))))

    (defun org-roam-backlink-query ()
      "Simple org-roam query function that stores the IDs of all the files that link
      to the node at point. This is a modified part of the
      `org-roam-backlinks-get' function keeping only the part necessary for
      `org-roam-backlink-files' to work as this is a complimentary function to
      that"
      (org-roam-db-query
       [:select [source dest]
		:from links
		:where (= dest $s1)
		:and (= type "id")]
       (org-roam-node-id (org-roam-node-at-point))))

    (defun org-roam-backlink-files ()
	"Get all nodes that link to the node at point with the
	`org-roam-backlink-query' function, find their absolute path and save
	a list of those paths to the buffer local variable
	`org-roam-backlinks'.

      With the list, you can act on all those files together. This is
      exceptionally useful with index files as it allows you to do an action
      on all files linked to this index automatically."
	(interactive)
	(let ((backlinks (length (org-roam-backlink-query)))
	      (org-roam-backlinks))
	  (dotimes (number backlinks)
	    (let* ((id (car (nth number (org-roam-backlink-query))))
		   (node (org-roam-node-from-id id)))
	      (setq-local org-roam-backlinks (cons (org-roam-node-file node) org-roam-backlinks))))
	  (message "%s" org-roam-backlinks)))

    (defun org-roam-export-backlinks-to-latex-pdf ()
      "Export the current buffer and every buffer that mentions it to a pdf through latex and pandoc. Makes use of the `org-roam-backlink-files' function to find all the backlinks. Also saves all the pdf names in a variable called `org-roam-backlink-pdfs'. These names can then be passed to something like pdftk to merge them into one pdf"
      (interactive)
      (org-roam-backlink-files)
      (setq org-roam-backlink-pdfs nil)
      (save-current-buffer
	(let ((backlinks (cons (buffer-file-name) org-roam-backlinks))
	      (org-startup-with-latex-preview nil))
	  (while backlinks
	    (find-file (car backlinks))
	    (org-pandoc-export-to-latex-pdf)
	    (setq org-roam-backlink-pdfs
		  (cons (concat (file-name-sans-extension (car backlinks)) ".pdf") org-roam-backlink-pdfs))
	    (setq backlinks (cdr backlinks)))
	  ))
      (message "%s" "Done!"))

  #+END_SRC
  
* Implementing the Zettelkasten "desktop" to org-roam 
  A desktop, is the top surface of a desk, or in the digital world an area in a computer screen in which some people arrange their icons, similarly to how they would arrange stuff in their desk. Now if I had an irl zettelkasten, I know for sure that my desktop would be filled with little notes with various topic when studying something. So why shouldn't I have a digital desktop where I can spread all my notes and look at them one by one, when studying. Wouldn't that be handy?

  This very thought is what started this idea. The idea of the zettelkasten-desktop, which I shortened to zetteldesk as I wanted my functions to not have huge names. The plan for the finished project is a dedicated buffer in which I can input whichever note I want and view them all at the same time, a way to create a true desktop experience inside emacs. Once done, it will be a great benefit to my workflow I believe.

  So far, I have done only what I would consider to be the first part of the workflow. I have created a system which marks an org-roam-node (from a completion menu) and adds it to the zetteldesk and a filtered org-roam-node-find which shows me only those nodes. Furthermore, the node doesn't have to be open currently, the functions take care of opening nodes. As I liked the idea, I thought it should be something I can do with any buffer. A lot of the times when studying, or doing any sort of research, you need not only your notes and a place to combine your ideas, but also supplementary materials to that work. That might be a pdf, a directory structure, an info page or whatever else suits your boat. So all the functionality written has a version for nodes and one generally for buffers.

  If for some reason you like this idea and want to use it, take note that the functions below depend on the functions org-roam-backlink-query and org-roam-node-buffer defined in above sections. 

#+BEGIN_SRC elisp :tangle yes

  (defvar-local zetteldesk "default"
    "Buffer local variable that determines whether a buffer is part of the current zetteldesk. A buffer is part of the zetteldesk only if the value of this variable is not its default value in that buffer. Its default value is default because I am not creative.")

  (defun zetteldesk-p (BUFFER)
    "Check if BUFFER is part of the current `zetteldesk'

  This function is used as the filter to create the `zetteldesk-switch-to-buffer' function."
    (not (eq (default-value 'zetteldesk) (buffer-local-value 'zetteldesk (cdr BUFFER)))))

  (defun zetteldesk-node-p (NODE)
    "Check if NODE is associated with an open buffer. If it is, check if that buffer is part of the current `zetteldesk'. If it isn't, return nil. 

  This function is used as a filter function to create `zetteldesk-node-find' which is a filtered view of `org-roam-node-find'"
    (if (org-roam-node-buffer NODE)
	(not (eq (default-value 'zetteldesk) (buffer-local-value 'zetteldesk (org-roam-node-buffer NODE))))
      nil))

  (defun zetteldesk-add-to-desktop (BUFFER)
    "Add BUFFER to the current `zetteldesk'"
    (interactive "b")
    (with-current-buffer BUFFER
      (setq-local zetteldesk "foo")))

  (defun zetteldesk-add-node-to-desktop ()
    "Add an org-roam-node to the `zetteldesk' and if there isn't a buffer associated to it, create it.

  The node is read through `org-roam-node-read'"
    (interactive)
    (let* ((node (org-roam-node-read))
	   (buffer (org-roam-node-buffer node))
	   (file (org-roam-node-file node))
	   (org-startup-with-latex-preview nil))
      (if (not (eq buffer nil))
	  (with-current-buffer buffer
	    (setq-local zetteldesk "foo"))
	(with-current-buffer (find-file-noselect file)
	  (setq-local zetteldesk "foo")))))

  (defun zetteldesk-remove-from-desktop (BUFFER)
    "Remove BUFFER from the current `zetteldesk'"
    (interactive "b")
    (with-current-buffer BUFFER
      (kill-local-variable 'zetteldesk)))

  (defun zetteldesk-add-backlinks-to-desktop ()
    "Add the current buffer and all its backlinks to the `zetteldesk'. 

  This function queries the database for all the nodes that link to the current node with the `org-roam-backlink-query' function and then recursively checks if there is an open buffer associated with them, and if so adds it to the `zetteldesk'"
    (interactive)
    (setq-local zetteldesk "foo")
    (let ((backlinks (length (org-roam-backlink-query)))
	  (org-startup-with-latex-preview nil))
      (dotimes (number backlinks)
	(let* ((id (car (nth number (org-roam-backlink-query))))
		(node (org-roam-node-from-id id))
		(buffer (org-roam-node-buffer node))
		(file (org-roam-node-file node)))
	  (if (not (eq buffer nil))
	      (with-current-buffer buffer
		(setq-local zetteldesk "foo"))
	    (with-current-buffer (find-file-noselect file)
	      (setq-local zetteldesk "foo")))))))

  (defun zetteldesk-remove-backlinks-from-desktop ()
    "Remove the current buffer and all its currently open backlinks from the `zetteldesk'. 

  This function is essentially a carbon copy of `zetteldesk-add-backlinks-to-desktop' but instead of adding the buffer to the desktop it removes it."
    (interactive)
    (kill-local-variable 'zetteldesk)
    (let ((backlinks (length (org-roam-backlink-query))))
      (dotimes (number backlinks)
	(let* ((id (car (nth number (org-roam-backlink-query))))
		(node (org-roam-node-from-id id))
		(buffer (org-roam-node-buffer node)))
	  (unless (eq buffer nil)
	    (with-current-buffer buffer
	      (kill-local-variable 'zetteldesk)))))))

  (defun zetteldesk-switch-to-buffer ()
    "Execute `switch-to-buffer' with the buffer list being filtered (using `zetteldesk-p') to show only buffers that are part of the current `zetteldesk'."
    (interactive)
    (switch-to-buffer (read-buffer "Zettelkasten Desktop Buffers: " nil nil #'zetteldesk-p)))

  (defun zetteldesk-node-find ()
    "Execute `org-roam-node-find' with the list being filtered (using `zetteldesk-node-p') to show only nodes that are part of the current `zetteldesk'"
    (interactive)
    (org-roam-node-find nil nil #'zetteldesk-node-p))

#+END_SRC

#+RESULTS:
: zetteldesk-node-find

I tried to follow a rather simple idea to do this and not overcomplicate things. Essentially, I define a buffer-local variable and give it a default value. Then I define the predicate function that shows when a buffer is part of the zettelkasten desktop. A buffer will be part of the desktop only if the value of that variable in the buffer is not equal to the default. 

Then I define a way to add or remove a file from the desktop, and finally the point of all of this, my custom switch-to-buffer function which lists only buffers that belong to the desktop and nothing more using the predicate function defined above to filter. 
    
* Bibtex completion (Ivy) and Org-Ref
  Ivy Bibtex and Org ref are two excellent packages for managing bibliography. The main thing I need to configure is the location of my master .bib file and pdfs (which are exported with Zotero). I also change some other variables where I see fit.
   
  In detail
  - Zotero exports a .bib file with all my references (the main way it "talks" to Emacs). I "tell" ivy-bibtex and org-ref the location of this file for usage in their various commands.
  - I allow ivy-bibtex to query by keywords or abstract. Can be useful
  - I make the default action of ivy-bibtex, the edit notes action. Personally, its the action I use most as opening the link/pdf to the reference (which is the original default) is more easily done from Zotero imo. In Emacs I find more utility in this function creating bibliographical notes.
  - Since opening the pdf, url or DOI of a bibtex entry is no longer the default action in my config, I bind it to the letter p in the options menu of Ivy-bibtex
  - Change the citation format bibtex uses on org mode. I enter cite links with org-ref-insert-cite-links so I make the ivy-bibtex link be a link to the pdf.

     #+BEGIN_SRC elisp :tangle yes
       (setq bibtex-completion-bibliography
	     '("~/Sync/My_Library.bib")
	     bibtex-completion-pdf-field "File"
	     bibtex-completion-library-path '("~/Sync/Zotero_pdfs"))
	
       (setq bibtex-completion-additional-search-fields '(keywords abstract))
	
       (setq ivy-bibtex-default-action 'ivy-bibtex-edit-notes)
       (ivy-add-actions
	'ivy-bibtex
	'(("p" ivy-bibtex-open-any "Open pdf, url or DOI")))
	
       (setq bibtex-completion-format-citation-functions
	     '((org-mode . bibtex-completion-format-citation-org-title-link-to-PDF)
	       (latex-mode . bibtex-completion-format-citation-cite)
	       (markdown-mode . bibtex-completion-format-citation-pandoc-citeproc)
	       (python-mode . bibtex-completion-format-citation-sphinxcontrib-bibtex)
	       (rst-mode . bibtex-completion-format-citation-sphinxcontrib-bibtex)
	       (default . bibtex-completion-format-citation-default)))
    #+END_SRC

* Org Roam Bibtex, Protocols (Reference notes) and UI (graphing capabilities)
   I require a bunch of packages so ORB, org roam ui and the roam protocols work as intended. I also make orb use ivy for completions.

   For a brief description of each ones use case, org-roam-bibtex (aka ORB) is an excellent package for bibliography management inside org-roam. Since other packages help out with this, the big thing this one does is that it hooks bibtex-completion to use the org-roam ecosystem for its notes. Org-protocol is for capturing info from a web page and adding it to an org file. The org-roam-protocol is basically integrating that to the org-roam ecosystem. Org-roam-ui is the new graphing package designed for org-roam-v2. We used to use org-roam-server for this, but with the migration to v2, this package was created (which is honestly better than org-roam-server) for an excellent visual graph of your org roam directory. There are many advantages to viewing your knowledge repository with a graph so this is a must have package. 

#+BEGIN_SRC elisp :tangle yes
  
  (require 'org-roam-bibtex)
  (org-roam-bibtex-mode 1)
  
  (setq orb-insert-interface 'ivy-bibtex
	orb-note-actions-interface 'ivy)
  (setq orb-preformat-keywords '("citekey" "author" "date" "entry-type" "keywords" "url" "file"))
  
  (require 'org-protocol)
  (require 'org-roam-protocol)
  
  (require 'websocket)
  (require 'org-roam-ui)
  
#+END_SRC


* Fleeting notes
   This is one of the more interesting sections of my workflow as its really custom and from what I have seen really unique. The zettelkasten method has a concept of fleeting notes. They are small notes which should be easy and non intrusive to write quickly to capture ideas and need to be archived when done. I "abuse" the todo-keywords org provides for this to completely repurpose them into what I need. As mentioned above, my org-roam-node-find UI shows the todo state of files which have one. 

Now which files have a todo state? Since org-roam-v2, headings can have IDs and can become nodes. Headings can also have a todo state. The todo states I use are helpful for me for a lot purposes. Inbox, Processing, To-Read and Wait show in which level of editing something is while Urgent is there for things I need to get to ASAP and Low-Priority is for things I want to remember but I can do them whenever. This gives me a lot of flexibility in my daily (fleeting) notes as I can define all of these and then search my zettelkasten for things with this keyword. But, headings have neither an ID nor a todo state in their creation. So I created a function which gives these to a new heading. Together with these, it links the fleeting note to a file named Current Projects, which acts as an index for my fleeting notes so they are not fully disconnected from the system and I have another way of viewing all of them together. To add the link without a prompt (such as that of org-roam-node-insert) I use a skeleton which adds an ID link to that file. 

Lastly, for this system to work properly for fleeting notes I need a seamless way of archiving my daily notes once I am done with the idea they store. For that, we need to define a function which deleted the ID of a node. But running that manually is by no means seamless and in my opinion unacceptable. An idea I found which works perfectly for this is the last code snippet in this section. Essentially, it adds to the org-after-todo-state-change-hook a check of what the new keyword is. If it is DONE, it runs org-id-delete-entry, deleting the ID. Therefore, whenever I set the item's state to done, it removes its ID archiving it from the system. But the file is never deleted, so if I want the context again, I can look for it in the daily directory. But, if I were to do this with the org-roam-dailies package I would reach a big problem. As the file itself gets an ID but not a todo state, it would have an ID which isn't removable automatically, something which would as mentioned above break the system in my opinion. So, these files are created with org-journal so that I can give IDs only to the headings. There isn't much configuration on that end, just some different formatting to a format I think makes more sense. 
   
#+BEGIN_SRC elisp :tangle yes

  (setq org-todo-keywords
	'((sequence "INBOX(i)"
		    "PROCESSING(p)"
		    "URGENT(u)"
		    "LOW-PRIORITY(l)"
		    "WAIT(w)"
		    "TO-READ(r)"
		    "|"
		    "DONE(d)"
		    )))

  (setq org-agenda-files
	'("~/org_roam"
	  "~/org_roam/daily"
	  "~/org_roam/ref"))

  (setq org-journal-dir "~/org_roam/daily"
	org-journal-file-format "%d-%m-%Y.org"
	org-journal-time-format "%a, %m/%d-%R")

  (add-hook 'org-agenda-mode-hook 'visual-line-mode)

  (define-skeleton project-skeleton
    "This skeleton inserts a link to the Current Projects file in the org-roam directory. 

  Its used in my fleeting note initialization function as a means to always make new fleeting notes point to the current projects file, as that is that files purpose"
    ""
    "- tags :: [[id:b5e71fe5-9d76-4f7f-b58d-df6a561e6a6b][Current Projects]]")

  (defun org-roam-init-fleeting-note ()
    "Prescribe an ID to the heading making it a node in org-roam, then add it the inbox by giving it a todo keyword. Finally, insert a new line and the `project-skeleton', linking the new file to the Current Projects file.

   This helps automate the process of creating new fleeting notes in combination with the `org-journal' commands"
    (interactive)
    (org-id-get-create)
    (evil-open-below 1)
    (project-skeleton)
    (org-todo))

  (defun org-id-delete-entry ()
  "Remove/delete an ID entry. Saves the current point and only does this if inside an org-heading."
  (interactive)
    (save-excursion
      (org-back-to-heading t)
      (when (org-entry-delete (point) "ID"))))

  (add-to-list 'org-after-todo-state-change-hook
	       (lambda ()
		 (when (equal org-state "DONE")
		   (org-id-delete-entry))))

  (defun org-roam-node-find-todos ()
    "Filtered view of org-roam-node-find which displays only nodes with a todo state. All my fleeting notes typically have a todo state indicating I need to work on them so this filter helps me out"
    (interactive)
    (org-roam-node-find nil nil #'org-roam-node-todo))

#+END_SRC


* Capture Templates
   Capture templates are really the "heart" of my zettelkasten workflow. By having a prefefined form for all files I create with the system I do not lose time trying to get a standard format on them. Its very important therefore to have at least a well customised default template. The rest of my templates here are for the capturing of specific things. Mine isn't that special but it has some important things.  

The project template is a rather new one to my workflow. The zettelkasten workflow defines a type of notes called project notes which you are meant to use to plan out your project inside the zettelkasten. Because of all the ideas there, you never have to start from a blank box but you can take ideas from anywhere and add them to a project file. This part of my workflow isn't polished yet, but I am thinking of using a project file for each project and then headings which I can make nodes for each part of the project I want to document. Each heading can be archived easily with the same method as the daily files. For the central project file, I could archive them by removing their ID manually or something better if I figure it out. 

Anoter idea for this which is more zettelkasten-y (yes that is a word now, deal with it) is to have a file for each section of the project and link all of them (either to an index or through the use of filetags) together. The problem is that then archiving becomes harder unless I figure out a good, easy and frictionless way of archiving files by removing their ID. This part is heavily WIP though as I said already

Then the other 2 templates I define are used for bibliographic information. Basic part of these is that they are stored in a subdirectory of the org_roam folder named ref and have tags depending on what type of file they are. For example, all articles I have have a tag article, and books have a tag book. The bibliography reference template is for things stored in my .bib file. This is mostly things like scientific articles. This is a very neat template as it uses a lot of the information the bibliography file has to make the template really functional. My favourite part of it is that if the entry has a pdf file attached to it, it will automatically set up org-noter to work with that file. The other template I use (info reference) is for creating reference notes from emacs info buffers. org-roam-capture-templates holds some special values if it is invoked in some special buffers one of which is the info-buffer. Specifically, it stores that the capture process was started in an info buffer, which file the buffer was visiting and which node it was in. With this info (no pun intended) and some elisp magic, you can automatically create a link that points to the info buffer the capture was invoked from so you have a reference point when you look at the note again. I found this a very cool feature of org-roam-capture-templates so I integrated it in a template. 

Also part of my templates I use for bibliographic information, is the org-roam-capture-ref-templates variable. This one is invoked when one captures a web page using org-roam-protocol. Besides books, articles, info pages and whatever else the above 2 cover, capturing info from a web page, is very important to my workflow. So I need to have a good template for it. Its not much, but its important. Org-roam-protocol doesn't store much special info besides the title of the web page so this template is about as simple as my default one. 

Lastly, I define the org-roam-dailies-capture-templates. As discussed above I do not use these too much, but since I have tried them I have kept the template I made for them. Its got the same formatting as the org-journal ones so if a file is created with one method the other can add things to it.

   #+BEGIN_SRC elisp :tangle yes
     
     (setq org-roam-capture-templates
	   '(("d" "default" plain "%?" :if-new
	      (file+head "${slug}-%<%d-%m-%y>.org" "#+title: ${title}\n
     - index ::  
     - tags ::  ")
	      :unarrowed t
	      :jump-to-captured t)
     
	     ("p" "project" plain "%?" :if-new
	      (file+head "project/${slug}-%<%d-%m-%y>.org" "#+title: ${title}\n
     - index ::  
     - tags ::  
     ,#+filetags: ")
	      :unarrowed t
	      :jump-to-captured t)
     
	     ("r" "bibliography reference" plain
	      "%?"
	      :if-new
	      (file+head "ref/${citekey}.org" "#+title: ${title}\n
     ,#+filetags: ${entry-type}
     - keywords :: ${keywords}
     - tags :: 
     
     ,* Analysis of ${entry-type} by ${author}
     :PROPERTIES:
     :URL: ${url}
     :NOTER_DOCUMENT: ${file}  
     :NOTER_PAGE:              
     :END:")
	      :unnarrowed t
	      :jump-to-captured t)
     
	     ("i" "info reference" plain
	      "%?"
	      :if-new
	      (file+head "ref/${slug}.org" "#+title: ${title}\n
     ,#+filetags: %:type
     - tags :: 
     
     [[elisp:(Info-goto-node \"(%:file)%:node\")][Link to Info page]]
     \n
     ")
	      :unnarowed t)))
     
     (setq org-roam-capture-ref-templates 
	   '(("r" "ref" entry "* %?" :target
	      (file+head "ref/${slug}.org" "#+title: ${title}\n
     ,#+filetags: 
      - tags :: ")
	      :unnarrowed t
	      :jump-to-captured t)))
     
     (setq org-roam-dailies-capture-templates
	   '(("d" "default" entry "* %?" :if-new
	      (file+head "%<%Y-%m-%d>.org" "#+title: %<%Y-%m-%d>\n#+filetags: daily")
	      :empty-lines 1)))
     
   #+END_SRC


* Providing the package to be loaded in init.el
  #+BEGIN_SRC elisp :tangle yes

    (provide 'zettelkasten)

  #+END_SRC
  
