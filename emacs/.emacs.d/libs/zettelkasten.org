#+TITLE: Org-Roam, References and the Zettelkasten Workflow

This file is a core part of my emacs configuration and is all about my Org-roam setup and my reference management inside org. Its based on the Zettelkasten method and the Roam Research website. Notes are linked with one another. Bibtex completion (and the existence of .bib files in general) as well as Org-ref help manage bibliographic references inside org. I also use Zotero as it easily allows me to gather my bibliographies. It exports a .bib file which these two use. Org Roam Bibtex (ORB) is a package that combines all of these to help you add citation links from org-ref inside an org-roam buffer. This section includes all the customisations and settings of these packages. This is a very large section of my config (hence why it has its own file) as I have really customised this workflow a lot. 

* Table of Contents                                                     :TOC:
- [[#org-roam-general-setup][Org-Roam general setup]]
- [[#useful-functions][Useful Functions]]
- [[#acting-on-backlinks][Acting on backlinks]]
- [[#bibtex-completion-ivy-and-org-ref][Bibtex completion (Ivy) and Org-Ref]]
- [[#org-roam-bibtex-protocols-reference-notes-and-ui-graphing-capabilities][Org Roam Bibtex, Protocols (Reference notes) and UI (graphing capabilities)]]
- [[#fleeting-notes][Fleeting notes]]
- [[#capture-templates][Capture Templates]]
- [[#implementing-the-zettelkasten-desktop-to-org-roam][Implementing the Zettelkasten "desktop" to org-roam]]
  - [[#dependencies][Dependencies]]
  - [[#predicate-functions][Predicate Functions]]
  - [[#adding-and-removing-things-in-the-zetteldesk][Adding and Removing things in the Zetteldesk]]
  - [[#filter-functions][Filter functions]]
  - [[#on-the-zetteldesk-scratch-buffer][On the zetteldesk-scratch buffer]]
  - [[#providing-the-package][Providing the package]]
- [[#providing-the-package-to-be-loaded-in-initel][Providing the package to be loaded in init.el]]

* Org-Roam general setup
  This part is the general setup of org-roam. It contains the setup, removing the warning message for the migration to v2, and the use-package declaration for org-roam. There I put the org roam directory, the various defmethods I use, my display template and a resize to the org-roam buffer as taking half the screen isn't something I like. I much prefer it to be a bit smaller than the main window.

  A lot of the defmethods defined here are for my display template as I think its useful to see directories, backlink count and todo state of nodes in the org-roam-node-find UI. Then there is the oddball org-roam-node-backlinkscount-number which is identical almosy to org-roam-node-backlinkscount, but its different output is useful for a function I define later and the org-roam-node-buffer defmethod which is a very helpful defmethod that imo should have been defined in org-roam. It returns the buffer associated to a node, and nil if there is none. I use this in various parts of my config and I consider it an important defmethod. 
   
 #+BEGIN_SRC elisp :tangle yes

   (add-hook 'after-init-hook 'org-roam-setup)
   (setq org-roam-v2-ack t)

   (use-package org-roam
     :config
     (setq org-roam-directory "~/org_roam/"
	   org-roam-dailies-directory "~/org_roam/daily")

     (cl-defmethod org-roam-node-directories ((node org-roam-node))
       "Access slot \"directory\" of org-roam-node struct CL-X"
       (if-let ((dirs (file-name-directory (file-relative-name (org-roam-node-file node) org-roam-directory))))
	   (format "(%s)" (car (f-split dirs)))
	 ""))

     (cl-defmethod org-roam-node-backlinkscount ((node org-roam-node))
       "Access slot \"backlinks\" of org-roam-node struct CL-X"
       (let* ((count (caar (org-roam-db-query
			    [:select (funcall count source)
				     :from links
				     :where (= dest $s1)
				     :and (= type "id")]
			    (org-roam-node-id node)))))
	 (format "[%d]" count)))

     (cl-defmethod org-roam-node-backlinkscount-number ((node org-roam-node))
       "Access slot \"backlinks\" of org-roam-node struct CL-X. This
       is identical to `org-roam-node-backlinkscount' with the
       difference that it returns a number instead of a fromatted
       string. This is to be used in
       `org-roam-node-sort-by-backlinks'"
       (let* ((count (caar (org-roam-db-query
			    [:select (funcall count source)
				     :from links
				     :where (= dest $s1)
				     :and (= type "id")]
			    (org-roam-node-id node)))))
	 count))

     (cl-defmethod org-roam-node-todostate ((node org-roam-node))
       "Modified version of org-roam-node-todo to look a bit better"
       (if-let ((state (org-roam-node-todo node)))
	   (format "Status: %s" state)))

     (cl-defmethod org-roam-node-buffer ((node org-roam-node))
       "Access slot \"buffer\" of org-roam-node struct CL-X"
       (let ((buffer (get-file-buffer (org-roam-node-file node))))
	 buffer))

     (setq org-roam-node-display-template "${title:100} ${backlinkscount:6} ${todostate:20} ${directories:10} ${tags:25}")

     (add-to-list 'display-buffer-alist
		  '("\\*org-roam\\*"
		    (display-buffer-in-direction)
		    (direction . right)
		    (window-width . 0.40)
		    (window-height . fit-window-to-buffer))))

   #+END_SRC

* Useful Functions
   Org roam is a cornerstone of my workflow (which is the reason this file is so stupidly large). I have written various "helper" functions for my own assistance that are meant to be used with org-roam. This section includes those functions. They are all documented well so I do not think I need to describe them. 

#+BEGIN_SRC elisp :tangle yes

  (defun org-roam-buffer-without-latex ()
      "Essentially `org-roam-buffer-toggle' but it ensures latex previews are turned off before toggling the buffer.

    This is useful because especially with index files, having
    latex previews on, makes opening the buffer very slow as it
    needs to load previews of many files. If you by default have
    `org-startup-with-latex-preview' set to t, you have probably
    noticed this issue before. This function solves it."
      (interactive)
      (let ((org-startup-with-latex-preview nil))
	(org-roam-buffer-toggle)))

  (defun org-roam-permanent-note-p (NODE)
    "Check if NODE is at the top level org_roam directory using the
    `org-roam-node-directories' function. If it isn't,
    `org-roam-node-directories' will return a non empty string,
    therefore this expression will evaluate to nil. The way my
    notes are sorted, when a note is placed on the top level its a
    permanent note, while fleeting and reference notes are placed
    in subdirectories.

  Therefore, this predicate function allows me to create a version
  of `org-roam-node-find' which only shows my permanent notes,
  which can be useful in some cases. That filtered function is
  `org-roam-find-permanent-node'."
    (string-equal (org-roam-node-directories NODE) ""))

  (defun org-roam-node-poi-or-moc-p (NODE)
    "Check if NODE has the tag POI or the tag MOC. Return t if it does"
    (or (string-equal (car (org-roam-node-tags NODE)) "POI")
	(string-equal (car (org-roam-node-tags NODE)) "MOC")))

  (defun org-roam-find-permanent-node ()
    "Execute `org-roam-node-find' with the list being filtered to
  only include permanent notes. In my system that is synonymous to
  saying include only notes at the top level directory. The
  filtering is done with the `org-roam-permanent-note-p' predicate
  function."
    (interactive)
    (org-roam-node-find nil nil #'org-roam-permanent-note-p))
#+END_SRC

* Acting on backlinks
  Backlinks are a pivotal part of this workflow. A file has a backlink if another file links to it. As a core part of my workflow revolves around index files (or Maps of Contents) and those are files that basically everything connected to that subject links to them, they end up being files with a lot of backlinks. I have some functions here that act on backlinks which I consider useful. Excluded from this list are two defmethods I use concerning backlinks as I define all my defmethods in the first part of the config.

  The first is org-roam-node-backlinkscount, a function I initially found on the OR wiki on github, which finds the number of backlinks a note has and formats them in a nice string. Its meant to be used with org-roam-node-display-template to show the number of backlinks in the org-roam-node-UI. The second is an almost identical function, but instead of returning a formatted string it returns a number. That is meant to be used with org-roam-node-sort-by-backlinks, a function defined below which sorts nodes by the number of backlinks they have. Number comparison is much easier than comparison of string representing numbers, and due to the extra formatting applied (which I like for the purpose that function has) I couldn't find how to convert that string to a number so I just made a rewrite with that small change.  

  #+BEGIN_SRC elisp :tangle yes

    (defvar-local org-roam-backlinks nil
      "Buffer local variable displaying a list of the absolute paths
      of all the files that are backlinked to current node. These are
      not added by default, and as such this variable has the value
      nil but they can be added by running the
      `org-roam-backlink-files' function on a node.")

    (defvar org-roam-backlink-pdfs nil
      "After running `org-roam-export-backlinks-to-latex-pdf', to
      export a node and all its backlinks to pdf, the value of this
      variable in the original node's buffer will become a list of
      all the pdfs that were created. This is to ease the process of
      combining them as the value of this variable can then be passed
      to a program such as pdftk to combine them.")

    (defun org-roam-node-sort-by-backlinks (completion-a completion-b)
      "Sorting function for org-roam that sorts the list of nodes by
    the number of backlinks. This is the sorting function in
    `org-roam-node-find-by-backlinks'"
      (let ((node-a (cdr completion-a))
	    (node-b (cdr completion-b)))
	(>= (org-roam-node-backlinkscount-number node-a)
	    (org-roam-node-backlinkscount-number node-b))))

    (defun org-roam-node-find-by-backlinks ()
      "Essentially works like `org-roam-node-find' (although it uses
    a combination of `find-file' and `org-roam-node-read' to
    accomplish that and not `org-roam-node-find' as only
    `org-roam-node-read' can take a sorting function as an argument)
    but the list of nodes is sorted by the number of backlinks
    instead of most recent nodes. Sorting is done with
    `org-roam-node-sort-by-backlinks'"
      (interactive)
      (find-file (org-roam-node-file (org-roam-node-read nil nil #'org-roam-node-sort-by-backlinks))))

    (defun org-roam-backlink-query ()
      "Simple org-roam query function that stores the IDs of all the
      files that link to the node at point. This is a modified part
      of the `org-roam-backlinks-get' function keeping only the part
      necessary for `org-roam-backlink-files' to work as this is a
      complimentary function to that"
      (org-roam-db-query
       [:select [source dest]
		:from links
		:where (= dest $s1)
		:and (= type "id")]
       (org-roam-node-id (org-roam-node-at-point))))

    (defun org-roam-backlink-files ()
	"Get all nodes that link to the node at point with the
	`org-roam-backlink-query' function, find their absolute path
	and save a list of those paths to the buffer local variable
	`org-roam-backlinks'.

      With the list, you can act on all those files together. This is
      exceptionally useful with index files as it allows you to do an
      action on all files linked to this index automatically."
	(interactive)
	(let ((backlinks (length (org-roam-backlink-query))))
	  (dotimes (number backlinks)
	    (let* ((id (car (nth number (org-roam-backlink-query))))
		   (node (org-roam-node-from-id id)))
	      (setq-local org-roam-backlinks (cons (org-roam-node-file node) org-roam-backlinks))))
	  org-roam-backlinks))

    (defun org-roam-export-backlinks-to-latex-pdf ()
      "Export the current buffer and every buffer that mentions it to
    a pdf through the org-latex export. Makes use of the
    `org-roam-backlink-files' function to find all the
    backlinks. Also saves all the pdf names in a variable called
    `org-roam-backlink-pdfs'. These names can then be passed to
    something like pdftk to merge them into one pdf"
      (interactive)
      (save-current-buffer
	(let ((backlinks (cons (buffer-file-name) org-roam-backlinks))
	      (org-startup-with-latex-preview nil))
	  (while backlinks
	    (find-file (car backlinks))
	    (org-latex-export-to-pdf)
	    (setq org-roam-backlink-pdfs
		  (cons (concat (file-name-sans-extension (car backlinks)) ".pdf") org-roam-backlink-pdfs))
	    (setq backlinks (cdr backlinks)))))
      (message "%s" "Done!"))

  #+END_SRC
  
* Bibtex completion (Ivy) and Org-Ref
  Ivy Bibtex and Org ref are two excellent packages for managing bibliography. The main thing I need to configure is the location of my master .bib file and pdfs (which are exported with Zotero). I also change some other variables where I see fit.
   
  In detail
  - Zotero exports a .bib file with all my references (the main way it "talks" to Emacs). I "tell" ivy-bibtex and org-ref the location of this file for usage in their various commands.
  - I allow ivy-bibtex to query by keywords or abstract. Can be useful
  - I make the default action of ivy-bibtex, the edit notes action. Personally, its the action I use most as opening the link/pdf to the reference (which is the original default) is more easily done from Zotero imo. In Emacs I find more utility in this function creating bibliographical notes.
  - Since opening the pdf, url or DOI of a bibtex entry is no longer the default action in my config, I bind it to the letter p in the options menu of Ivy-bibtex
  - Change the citation format bibtex uses on org mode. I enter cite links with org-ref-insert-cite-links so I make the ivy-bibtex link be a link to the pdf.

     #+BEGIN_SRC elisp :tangle yes
       (setq bibtex-completion-bibliography
	     '("~/Sync/My_Library.bib" "~/Sync/My_Library2.bib")
	     bibtex-completion-pdf-field "File"
	     bibtex-completion-library-path '("~/Sync/Zotero_pdfs"))
	
       (setq bibtex-completion-additional-search-fields '(keywords abstract))
	
       (setq ivy-bibtex-default-action 'ivy-bibtex-edit-notes)
       (ivy-add-actions
	'ivy-bibtex
	'(("p" ivy-bibtex-open-any "Open pdf, url or DOI")))
	
       (setq bibtex-completion-format-citation-functions
	     '((org-mode . bibtex-completion-format-citation-org-title-link-to-PDF)
	       (latex-mode . bibtex-completion-format-citation-cite)
	       (markdown-mode . bibtex-completion-format-citation-pandoc-citeproc)
	       (python-mode . bibtex-completion-format-citation-sphinxcontrib-bibtex)
	       (rst-mode . bibtex-completion-format-citation-sphinxcontrib-bibtex)
	       (default . bibtex-completion-format-citation-default)))
    #+END_SRC

* Org Roam Bibtex, Protocols (Reference notes) and UI (graphing capabilities)
   I require a bunch of packages so ORB, org roam ui and the roam protocols work as intended. I also make orb use ivy for completions.

   For a brief description of each ones use case, org-roam-bibtex (aka ORB) is an excellent package for bibliography management inside org-roam. Since other packages help out with this, the big thing this one does is that it hooks bibtex-completion to use the org-roam ecosystem for its notes. Org-protocol is for capturing info from a web page and adding it to an org file. The org-roam-protocol is basically integrating that to the org-roam ecosystem. Org-roam-ui is the new graphing package designed for org-roam-v2. We used to use org-roam-server for this, but with the migration to v2, this package was created (which is honestly better than org-roam-server) for an excellent visual graph of your org roam directory. There are many advantages to viewing your knowledge repository with a graph so this is a must have package. 

#+BEGIN_SRC elisp :tangle yes
  
  (require 'org-roam-bibtex)
  (org-roam-bibtex-mode 1)
  
  (setq orb-insert-interface 'ivy-bibtex
	orb-note-actions-interface 'ivy)
  (setq orb-preformat-keywords '("citekey" "author" "date" "entry-type" "keywords" "url" "file"))
  
  (require 'org-protocol)
  (require 'org-roam-protocol)
  
  (require 'websocket)
  (require 'org-roam-ui)
  
#+END_SRC

* Logseq-like tagging functionality
  I recently had a [[https://www.reddit.com/r/orgmode/comments/tgb7f9/orgroam_journey/i17ohct/?context=3][discussion]] with a fellow redditor on r/orgmode about how to get some useful features logseq has in org-roam. Especially, he told me how logseq handles tags and some useful features they have. Intrigued by the idea, I decided I could try and implement it to org-roam as a fun little project. It didn't sound so hard so I was like, sure why not. Here's the result I got. I don't even know if I am going to use this, but it can stay here for now. Note that it relies on org-transclusion to do a lot of the work. 

  #+BEGIN_SRC elisp :tangle zettelkasten.el

    (defun org-roam-node-sort-by-atime (NODE1 NODE2)
      "Sorting function that sorts NODE1 and NODE2 by their file atime.

    This is a simplified version of
    `org-roam-node-read-sort-by-file-atime' which requires nodes as
    its input and not something else. The above function is what
    `org-roam-node-read's sorting uses and it has a special
    formatting."
      (time-less-p (org-roam-node-file-atime NODE1)
		   (org-roam-node-file-atime NODE2)))

    (defun org-roam-logseq-tag-function (TAG)
      "An implementation of logseq's tagging system in org-roam.

    Prompt for TAG which is the name of a tag in your org-roam
    repository, filter it to only contain nodes with that tag and
    sort them so the most recently accessed one is the first item of
    the list. Sorting is done with the custom
    `org-roam-node-sort-by-atime' function. Then, check if a buffer
    exists with the name *TAG-nodes* and if it doesn't create it.

    In that new buffer, switch to org-mode and for every item in the
    sorted-nodes list, go to `point-max', insert a new line, insert
    the string #+transclude: make an org-mode id link with the node's
    id and insert another newline. Once done, run
    `org-transclusion-add-all' to activate the transclusion links and
    view editable versions of the selected nodes.

    Finally, restore the buffer from which this function was called
    and insert and org-mode elisp link that runs `switch-to-buffer'
    to switch to the newly-created buffer."
      (interactive "MTag: ")
      (let* ((init-list (org-roam-node-list))
	     (tagged-nodes (cl-remove-if-not (lambda (NODE)
					       (member TAG (org-roam-node-tags NODE)))
					     init-list))
	     (sorted-nodes (reverse (sort tagged-nodes #'org-roam-node-sort-by-atime)))
	     (buffer-name (concat "*" TAG "-nodes*"))
	     (buffer (get-buffer-create buffer-name)))
	(save-excursion
	  (with-current-buffer buffer
	    (org-mode)
	    (dolist (node sorted-nodes)
	      (goto-char (point-max))
	      (newline)
	      (insert
	       "#+transclude: "
	       (org-link-make-string
		(concat "id:" (org-roam-node-id node))))
	       (newline))
	    (org-transclusion-add-all)))
	(insert
	 (org-link-make-string
	  (concat "elisp:(switch-to-buffer \"" buffer-name "\")")
	  (concat "#" TAG)))))

  #+END_SRC

* Fleeting notes
   This is one of the more interesting sections of my workflow as its really custom and from what I have seen really unique. The zettelkasten method has a concept of fleeting notes. They are small notes which should be easy and non intrusive to write quickly to capture ideas and need to be archived when done. I "abuse" the todo-keywords org provides for this to completely repurpose them into what I need. As mentioned above, my org-roam-node-find UI shows the todo state of files which have one. 

Now which files have a todo state? Since org-roam-v2, headings can have IDs and can become nodes. Headings can also have a todo state. The todo states I use are helpful for me for a lot purposes. Inbox, Processing, To-Read and Wait show in which level of editing something is while Urgent is there for things I need to get to ASAP and Low-Priority is for things I want to remember but I can do them whenever. This gives me a lot of flexibility in my daily (fleeting) notes as I can define all of these and then search my zettelkasten for things with this keyword. But, headings have neither an ID nor a todo state in their creation. So I created a function which gives these to a new heading. Together with these, it links the fleeting note to a file named Current Projects, which acts as an index for my fleeting notes so they are not fully disconnected from the system and I have another way of viewing all of them together. To add the link without a prompt (such as that of org-roam-node-insert) I use a skeleton which adds an ID link to that file. 

Lastly, for this system to work properly for fleeting notes I need a seamless way of archiving my daily notes once I am done with the idea they store. For that, we need to define a function which deleted the ID of a node. But running that manually is by no means seamless and in my opinion unacceptable. An idea I found which works perfectly for this is the last code snippet in this section. Essentially, it adds to the org-after-todo-state-change-hook a check of what the new keyword is. If it is DONE, it runs org-id-delete-entry, deleting the ID. Therefore, whenever I set the item's state to done, it removes its ID archiving it from the system. But the file is never deleted, so if I want the context again, I can look for it in the daily directory. But, if I were to do this with the org-roam-dailies package I would reach a big problem. As the file itself gets an ID but not a todo state, it would have an ID which isn't removable automatically, something which would as mentioned above break the system in my opinion. So, these files are created with org-journal so that I can give IDs only to the headings. There isn't much configuration on that end, just some different formatting to a format I think makes more sense. 
   
#+BEGIN_SRC elisp :tangle yes

  (setq org-todo-keywords
	'((sequence "INBOX(i)"
		    "PROCESSING(p)"
		    "URGENT(u)"
		    "LOW-PRIORITY(l)"
		    "WAIT(w)"
		    "TO-READ(r)"
		    "|"
		    "DONE(d)"
		    )))

  (setq org-agenda-files
	'("~/org_roam"
	  "~/org_roam/daily"
	  "~/org_roam/ref"))

  (setq org-journal-dir "~/org_roam/daily"
	org-journal-file-format "%d-%m-%Y.org"
	org-journal-time-format "%a, %d/%m-%R")

  (add-hook 'org-agenda-mode-hook 'visual-line-mode)

  (define-skeleton project-skeleton
    "This skeleton inserts a link to the Current Projects file in the org-roam directory. 

  Its used in my fleeting note initialization function as a means
  to always make new fleeting notes point to the current projects
  file, as that is that files purpose"
    ""
    "- tags :: [[id:b5e71fe5-9d76-4f7f-b58d-df6a561e6a6b][Current Projects]]")

  (defun org-roam-init-fleeting-note ()
    "Prescribe an ID to the heading making it a node in org-roam, then
    add it the inbox by giving it a todo keyword. Finally, insert a new
    line and the `project-skeleton', linking the new file to the Current
    Projects file.

   This helps automate the process of creating new fleeting notes
   in combination with the `org-journal' commands"
    (interactive)
    (org-id-get-create)
    (evil-open-below 1)
    (project-skeleton)
    (org-todo))

  (defun org-id-delete-entry ()
  "Remove/delete an ID entry. Saves the current point and only does this if inside an org-heading."
  (interactive)
    (save-excursion
      (org-back-to-heading t)
      (when (org-entry-delete (point) "ID"))))

  (add-to-list 'org-after-todo-state-change-hook
	       (lambda ()
		 (when (equal org-state "DONE")
		   (org-id-delete-entry))))

  (defun org-roam-node-find-todos ()
    "Filtered view of org-roam-node-find which displays only nodes
  with a todo state. All my fleeting notes typically have a todo
  state indicating I need to work on them so this filter helps me
  out"
    (interactive)
    (org-roam-node-find nil nil #'org-roam-node-todo))

#+END_SRC


* Capture Templates
   Capture templates are really the "heart" of my zettelkasten workflow. By having a prefefined form for all files I create with the system I do not lose time trying to get a standard format on them. Its very important therefore to have at least a well customised default template. The rest of my templates here are for the capturing of specific things. Mine isn't that special but it has some important things.

   The outline capture template is part of the workflow I have crafted with the functions of the zetteldesk (see below). Essentially they are used for outlining a subject during revision and are files that are densely linked with everything that has to do with the subject. After done, they are archived (meaning I remove their ID) as they annoy me in org-roam-node-find and org-roam-ui. I have a shortcut to jump to the directory in which they are located so I do not really fear losing them. One might ask why make them through org roam in the first place if I am going to remove their ID. Well the answer is simple. Its easier this way. While working on it, I want it to be a node so I can find it faster with org-roam commands. But when done, its not actually useful info to keep, so I archive it, but its stored in its own directory so I can find it if I need it again. 

   Then the other 2 templates I define are used for bibliographic information. Basic part of these is that they are stored in a subdirectory of the org_roam folder named ref and have tags depending on what type of file they are. For example, all articles I have have a tag article, and books have a tag book. The bibliography reference template is for things stored in my .bib file. This is mostly things like scientific articles. This is a very neat template as it uses a lot of the information the bibliography file has to make the template really functional. My favourite part of it is that if the entry has a pdf file attached to it, it will automatically set up org-noter to work with that file. The other template I use (info reference) is for creating reference notes from emacs info buffers. org-roam-capture-templates holds some special values if it is invoked in some special buffers one of which is the info-buffer. Specifically, it stores that the capture process was started in an info buffer, which file the buffer was visiting and which node it was in. With this info (no pun intended) and some elisp magic, you can automatically create a link that points to the info buffer the capture was invoked from so you have a reference point when you look at the note again. I found this a very cool feature of org-roam-capture-templates so I integrated it in a template. 

   Also part of my templates I use for bibliographic information, is the org-roam-capture-ref-templates variable. This one is invoked when one captures a web page using org-roam-protocol. Besides books, articles, info pages and whatever else the above 2 cover, capturing info from a web page, is very important to my workflow. So I need to have a good template for it. Its not much, but its important. Org-roam-protocol doesn't store much special info besides the title of the web page so this template is about as simple as my default one. 

   Lastly, I define the org-roam-dailies-capture-templates. As discussed above I do not use these too much, but since I have tried them I have kept the template I made for them. Its got the same formatting as the org-journal ones so if a file is created with one method the other can add things to it.

   #+BEGIN_SRC elisp :tangle yes

     (setq org-roam-capture-templates
	   '(("d" "default" plain "%?" :if-new
	      (file+head "${slug}-%<%d-%m-%y>.org" "#+title: ${title}\n
     - index ::  
     - tags :: ")
	      :unarrowed t
	      :jump-to-captured t)

	     ("o" "outline" plain "%?" :if-new
	      (file+head "outlines/${slug}-%<%d-%m-%y>.org" "#+title: ${title}\n
     ,#+filetags: outline")
	      :unarrowed t
	      :jump-to-captured t)

	     ("r" "bibliography reference" plain
	      "%?"
	      :if-new
	      (file+head "ref/${citekey}.org" "#+title: ${title}\n
     ,#+filetags: ${entry-type}
     - keywords :: ${keywords}
     - tags :: 

     ,* Analysis of ${entry-type} by ${author}
     :PROPERTIES:
     :URL: ${url}
     :NOTER_DOCUMENT: ${file}  
     :NOTER_PAGE:              
     :END:")
	      :unnarrowed t
	      :jump-to-captured t)

	     ("i" "info reference" plain
	      "%?"
	      :if-new
	      (file+head "ref/${slug}.org" "#+title: ${title}\n
     ,#+filetags: %:type
     - tags :: \n

     [[elisp:(Info-goto-node \"(%:file)%:node\")][Link to Info page]]
     \n
     ")
	      :unnarowed t)

	     ("e" "elfeed" plain
	      "%?"
	      :if-new
	      (file+head "ref/${slug}.org" "#+title: %:description\n
     ,#+filetags: %:type
     - keywords ::
     - tags :: \n\n\n

     [[%:link][Link to Elfeed Buffer]]
     [[%:elfeed-entry-link][Link to Web Page]]")
	      :unnarowed t)))

     (setq org-roam-capture-ref-templates 
	   '(("r" "ref" entry "* %?" :target
	      (file+head "ref/${slug}.org" "#+title: ${title}\n
     ,#+filetags: 
      - tags :: \n")
	      :unnarrowed t
	      :jump-to-captured t)))

     (setq org-roam-dailies-capture-templates
	   '(("d" "default" entry "* %?" :if-new
	      (file+head "%<%Y-%m-%d>.org" "#+title: %<%Y-%m-%d>\n#+filetags: daily")
	      :empty-lines 1)))

   #+END_SRC

   #+RESULTS:
   | d | default | entry | * %? | :if-new | (file+head %<%Y-%m-%d>.org #+title: %<%Y-%m-%d> |


* Implementing the Zettelkasten "desktop" to org-roam 
  A desktop, is the top surface of a desk, or in the digital world an area in a computer screen in which some people arrange their icons, similarly to how they would arrange stuff in their desk. Now if I had an irl zettelkasten, I know for sure that my desktop would be filled with little notes with various topic when studying something. So why shouldn't I have a digital desktop where I can spread all my notes and look at them one by one, when studying. Wouldn't that be handy?

  This very thought is what started this idea. The idea of the zettelkasten-desktop, which I shortened to zetteldesk as I wanted my functions to not have huge names. The plan for the finished project is a dedicated buffer in which I can input whichever note I want and view them all at the same time, a way to create a true desktop experience inside emacs. Once done, it will be a great benefit to my workflow I believe.

  So far, I have done only what I would consider to be the first part of the workflow. I have created a system which marks an org-roam-node (from a completion menu) and adds it to the zetteldesk and a filtered org-roam-node-find which shows me only those nodes. Furthermore, the node doesn't have to be open currently, the functions take care of opening nodes. As I liked the idea, I thought it should be something I can do with any buffer. A lot of the times when studying, or doing any sort of research, you need not only your notes and a place to combine your ideas, but also supplementary materials to that work. That might be a pdf, a directory structure, an info page or whatever else suits your boat. So all the functionality written has a version for nodes and one generally for buffers.

  I plan for this to become its own emacs package for people to use. Now some of its functionality is and will be really specific to my workflow, but hopefully others may like it and use it. For this reason this section tangles to a different file zetteldesk.el. 

** Description
   I plan to publish this as a package on github so a description is needed in the top of the file. This section is basically that part.

   #+BEGIN_SRC elisp :tangle zetteldesk.el

     ;;; zetteldesk.el --- A revision and outlining tool for org-roam

     ;; Author: Vidianos Giannitsis <vidianosgiannitsis@gmail.com>
     ;; Maintaner: Vidianos Giannitsis <vidianosgiannitsis@gmail.com>
     ;; URL: https://github.com/Vidianos-Giannitsis/zetteldesk.el
     ;; Package-Requires: ((org-roam "2.0"))
     ;; Tested on Emacs 27.2 and org-roam v2.2
     ;; Created: 6th February 2022
     ;; License: GPL-3.0
     ;; Keywords: org-roam, revision, zettelkasten
     ;; Version: 0.2

     ;; This file is free software; you can redistribute it and/or modify
     ;; it under the terms of the GNU General Public License as published by
     ;; the Free Software Foundation; either version 3, or (at your option)
     ;; any later version.

     ;; This program is distributed in the hope that it will be useful,
     ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
     ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     ;; GNU General Public License for more details.

     ;; For a full copy of the GNU General Public License
     ;; see <https://www.gnu.org/licenses/>.

     ;;; Commentary:

     ;; This package provides various filter functions to "traverse" your
     ;; org-roam database more smoothly.  I use it for doing revision in
     ;; lessons and I personally find it highly efficient for this
     ;; purpose.  Its also good to just sort out your thoughts.  In general,
     ;; org-roam lacks a good framework for filtering your nodes although
     ;; it has all the backend for doing that.

     ;;; Code:
   #+END_SRC
   
** Dependencies
   As I want this to work independently to my config, this section has a copy of all the custom function I use which were not defined in this section as I felt they fit more somewhere else in my config. These are the dependencies this has from my config. For general dependencies I will do those once this is actually complete enough to make its own package

   #+BEGIN_SRC elisp :tangle zetteldesk.el

     ;; -- DEPENDENCIES --
     ;; These are some functions that are needed for the package to work as
     ;; it should, but that are not specific to the package

     (require 'org-roam)

     (cl-defmethod org-roam-node-buffer ((node org-roam-node))
       "Access slot \"buffer\" of org-roam-node struct CL-X.
     NODE is an org-roam-node"
       (let ((buffer (get-file-buffer (org-roam-node-file node))))
	 buffer))

     (cl-defmethod org-roam-node-backlinkscount-number ((node org-roam-node))
	 "Access slot \"backlinks\" of org-roam-node struct CL-X. This
	 is identical to `org-roam-node-backlinkscount' with the
	 difference that it returns a number instead of a fromatted
	 string. This is to be used in
	 `org-roam-node-sort-by-backlinks'"
	 (let* ((count (caar (org-roam-db-query
			      [:select (funcall count source)
				       :from links
				       :where (= dest $s1)
				       :and (= type "id")]
			      (org-roam-node-id node)))))
	   count))

     (defun org-roam-node-poi-or-moc-p (NODE)
       "Check if NODE has the tag POI or the tag MOC.  Return t if it does."
       (or (string-equal (car (org-roam-node-tags NODE)) "POI")
	   (string-equal (car (org-roam-node-tags NODE)) "MOC")))

     (defun org-roam-backlink-query ()
       "Simple org-roam query function.
     Stores the IDs of all the files that link to the node at point.
     This is a modified part of the `org-roam-backlinks-get' function
     keeping only the part necessary for `org-roam-backlink-files' to
     work as this is a complimentary function to that"
       (org-roam-db-query
	[:select [source dest]
		 :from links
		 :where (= dest $s1)
		 :and (= type "id")]
	(org-roam-node-id (org-roam-node-at-point))))

     (defun org-roam-backlink-query* (NODE)
       "Run `org-roam-backlink-query'.
     Instead of returning a list of the backlinks of
     `org-roam-node-at-point', find the backlinks of NODE.  This is
     handy in cases where NODE is read through `org-roam-node-read'
     and doesn't have to be the `current-buffer'"
       (org-roam-db-query
	     [:select [source dest]
		      :from links
		      :where (= dest $s1)
		      :and (= type "id")]
	     (org-roam-node-id NODE)))

     (defun org-roam-node-sort-by-backlinks (completion-a completion-b)
       "Sorting function for org-roam that sort the list of nodes.
     Sorting is done accordint to the number of backlinks.  This is
     the sorting function in `org-roam-node-find-by-backlinks' and
     `zetteldesk-node-insert-sort-backlinks'.  Arguments COMPLETION-A
     and COMPLETION-B are same as in
     `org-roam-node-read-sort-by-file-atime'"
       (let ((node-a (cdr completion-a))
	     (node-b (cdr completion-b)))
	 (>= (org-roam-node-backlinkscount-number node-a)
	     (org-roam-node-backlinkscount-number node-b))))

   #+END_SRC
   
** Predicate Functions
I tried to follow a rather simple idea to do this and not overcomplicate things. Essentially, I define a buffer-local variable and give it a default value. Then I define the predicate function that shows when a buffer is part of the zettelkasten desktop. A buffer will be part of the desktop only if the value of that variable in the buffer is not equal to the default. I define the low level predicate functions that check if a buffer or node is part of the zetteldesk and then I define a predicate that checks if a buffer is part of the zetteldesk but not an org-roam file, as on the switch-to-buffer prompt I do not care about org-roam files (I can view them with org-roam-node-file) and another predicate which filters the list down further to only include org files that are part of the zetteldesk but not org-roam files (which is handy for another function below).

#+BEGIN_SRC elisp :tangle zetteldesk.el

  ;; -- PREDICATE FUNCTIONS --
  ;; This section contains the predicate functions the package uses. The
  ;; core of the package is that it provides well filtered completion
  ;; menus as chosen by the user, so obviously predicate functions are
  ;; core to the package

  (defcustom zetteldesk
    "default"
    "Buffer local variable.
  Checks if the current buffer is part of the zetteldesk.  A buffer
  is part of the zetteldesk only if the value of this variable is
  not its default value in that buffer.  Its default value is
  default because I am not creative."
    :type 'string
    :group 'zetteldesk
    :local t)

  (defun zetteldesk-p (BUFFER)
    "Check if BUFFER is part of the current `zetteldesk'."
    (not (eq (default-value 'zetteldesk) (buffer-local-value 'zetteldesk (cdr BUFFER)))))

  (defun zetteldesk-buffer-p (BUFFER)
    "Check if BUFFER is part of the current `zetteldesk'.
  Then check if BUFFER is not associated to an org-roam file.

  Org-roam file buffers are better viewed with `org-roam-node-file'
  so this function filters down the database to non org-roam
  zetteldesk buffers.  This is what is used to create the filter
  function `zetteldesk-switch-to-buffer'"
    (and (zetteldesk-p BUFFER) (not (org-roam-buffer-p (cdr BUFFER)))))

  (defun zetteldesk-node-p (NODE)
    "Check if NODE is associated with an open buffer.
  If it is, check if that buffer is part of the current
  `zetteldesk'.  If it isn't, return nil.

  This function is used as a filter function to create
  `zetteldesk-node-find' which is a filtered view of
  `org-roam-node-find'"
    (if (org-roam-node-buffer NODE)
	(not (eq (default-value 'zetteldesk) (buffer-local-value 'zetteldesk (org-roam-node-buffer NODE))))
      nil))

  (defun zetteldesk-org-buffer-p (BUFFER)
    "Check if BUFFER is part of the current `zetteldesk'.
  Then check if the file is an org file but not one that belongs to
  org-roam.

  This is used as the filter function for
  `zetteldesk-insert-org-file-contents' which prompts for an org
  file, but as `zetteldesk-insert-node-contents' is a superior
  version for org-roam nodes, that function should not prompts for
  those files"
    (and (zetteldesk-buffer-p BUFFER) (eq (buffer-local-value 'major-mode (cdr BUFFER)) 'org-mode)))

  (defun zetteldesk-pdf-p (BUFFER)
    "Check if BUFFER is part of the current `zetteldesk' and also a pdf file."
    (and (zetteldesk-p BUFFER) (eq (buffer-local-value 'major-mode (cdr BUFFER)) 'pdf-view-mode)))

#+END_SRC

#+RESULTS:
: zetteldesk-node-insert

** Adding and Removing things in the Zetteldesk
   I define a few adding mechanisms and the matching removing ones, as can seen below. The first is adding/removing a buffer, the second is for a node and then I have two ways of playing with a nodes backlinks. I can add a node and all its backlinks to the zetteldesk, or I can select a node and add one of its backlinks to the zetteldesk. Both have their use cases imo. For the last one, I believe there is no need for a matching removing one. 

   
  #+BEGIN_SRC elisp :tangle zetteldesk.el

    ;; -- ADD/REMOVE THINGS IN THE ZETTELDESK --
    ;; To get a system where the user can get multiple filtered views of
    ;; the nodes/buffers of their choice, obviously you need functions
    ;; that allow the user to add them to something. And then, you also
    ;; need ways to remove things, because people make mistakes.

    (defun zetteldesk-add-to-desktop (BUFFER)
      "Add BUFFER to the current `zetteldesk'."
      (interactive "b")
      (with-current-buffer BUFFER
	(setq-local zetteldesk "foo")))

    (defun zetteldesk-add-node-to-desktop (NODE)
      "Add NODE to the `zetteldesk'.
    If there isn't a buffer associated to it, create it.  NODE is an
    org-roam node read through `org-roam-node-read'"
      (interactive (list (org-roam-node-read)))
      (let ((buffer (org-roam-node-buffer NODE))
	     (file (org-roam-node-file NODE))
	     (org-startup-with-latex-preview nil))
	(if (not (eq buffer nil))
	    (with-current-buffer buffer
	      (setq-local zetteldesk "foo"))
	  (with-current-buffer (find-file-noselect file)
	    (setq-local zetteldesk "foo")))))

    (defun zetteldesk-add-poi-or-moc-backlink-to-desktop ()
      "Prompts the user to select an org-roam node that has a specific tag.
    Looks for the POI or MOC tag (filtering done with
    `org-roam-node-poi-or-moc-p') and collects its ID and backlinks.
    Then, prompt the user to select one of its backlinks and add that
    to the zetteldesk."
      (interactive)
      (let* ((source (org-roam-node-read nil #'org-roam-node-poi-or-moc-p))
	     (source-id (org-roam-node-id source))
	     (backlinks (org-roam-backlink-query* source)))
	(zetteldesk-add-node-to-desktop
	 (org-roam-node-read nil (lambda (NODE)
				   (let* ((id (org-roam-node-id NODE))
					  (id-list (list id source-id)))
				     (member id-list backlinks)))))))

    (defun zetteldesk-add-backlinks-to-desktop ()
      "Add the current buffer and all its backlinks to the `zetteldesk'.

    This function queries the database for all the nodes that link to
    the current node with the `org-roam-backlink-query' function and
    then recursively checks if there is an open buffer associated
    with them, and if so adds it to the `zetteldesk'"
      (interactive)
      (setq-local zetteldesk "foo")
      (let ((backlinks (length (org-roam-backlink-query)))
	    (org-startup-with-latex-preview nil))
	(dotimes (number backlinks)
	  (let* ((id (car (nth number (org-roam-backlink-query))))
		  (node (org-roam-node-from-id id))
		  (buffer (org-roam-node-buffer node))
		  (file (org-roam-node-file node)))
	    (if (not (eq buffer nil))
		(with-current-buffer buffer
		  (setq-local zetteldesk "foo"))
	      (with-current-buffer (find-file-noselect file)
		(setq-local zetteldesk "foo")))))))

    (defun zetteldesk-remove-from-desktop (BUFFER)
      "Remove BUFFER from the current `zetteldesk'."
      (interactive "b")
      (with-current-buffer BUFFER
	(kill-local-variable 'zetteldesk)))

    (defun zetteldesk-remove-node-from-desktop (NODE)
      "Remove NODE from the `zetteldesk'.
    NODE is an org-roam node
    and is read through `org-roam-node-read'"
      (interactive (list (org-roam-node-read nil #'zetteldesk-node-p)))
      (let ((buffer (org-roam-node-buffer NODE)))
	(with-current-buffer buffer
	  (kill-local-variable 'zetteldesk))))

    (defun zetteldesk-remove-backlinks-from-desktop ()
      "Remove from the `zetteldesk', the current buffer and its backlinks.

    This function is essentially a carbon copy of
    `zetteldesk-add-backlinks-to-desktop' but instead of adding the
    buffer to the desktop it removes it."
      (interactive)
      (kill-local-variable 'zetteldesk)
      (let ((backlinks (length (org-roam-backlink-query))))
	(dotimes (number backlinks)
	  (let* ((id (car (nth number (org-roam-backlink-query))))
		  (node (org-roam-node-from-id id))
		  (buffer (org-roam-node-buffer node)))
	    (unless (eq buffer nil)
	      (with-current-buffer buffer
		(kill-local-variable 'zetteldesk)))))))


  #+END_SRC 
   
** Filter functions
   Here I define the functions which give you a filtered view of switch-to-buffer and org-roam-node-find to the current zetteldesk. I also define a filtered view of org-roam-node-insert as its not rare to want to insert a link to a file from the zetteldesk and an iteration of that, that also sorts by backlinks.

   Lastly, trying to handle info buffers, I add a filtered view of Info-goto-node, using completing-read.

   #+BEGIN_SRC elisp :tangle zetteldesk.el

     ;; -- FILTER FUNCTIONS --
     ;; This section is about defining all the functions that show you the
     ;; filtered results of all your nodes/buffers

     (defun zetteldesk-switch-to-buffer ()
       "Execute a filtered `switch-to-buffer'.
     The filter is done using `zetteldesk-buffer-p' to show only
     buffers that are part of the current `zetteldesk' and not
     `org-roam-node's."
       (interactive)
       (switch-to-buffer (read-buffer "Zetteldesk Buffers: " nil nil #'zetteldesk-buffer-p)))

     (defun zetteldesk-node-find ()
       "Execute a filtered `org-roam-node-find'.
     The filter is done using `zetteldesk-node-p' to show only nodes that are
     part of the current `zetteldesk'"
       (interactive)
       (org-roam-node-find nil nil #'zetteldesk-node-p))

     (defun zetteldesk-node-insert ()
       "Execute a filtered `org-roam-node-insert'.
     The filter is done using `zetteldesk-node-p' to show only nodes that are
     part of the current `zetteldesk'"
       (interactive)
       (org-roam-node-insert #'zetteldesk-node-p))

     (defun zetteldesk-node-insert-sort-backlinks ()
       "Select a node that is part of the zetteldesk.
     The function used is `org-roam-node-read' in a UI sorted by the
       number of backlinks.  Insert a link in the current buffer to
       the selected node.

     This function essentially has the core functionality of
     `org-roam-node-insert', but it uses `org-roam-node-read' instead
     as only that can take a sort-function.  Some files may be
     important to their topic, but not MOCs or POIs, so this function
     acts essentially as a complimentary function to
     `zetteldesk-node-insert-if-poi-or-moc' to check if that one
     missed something you want to include."
       (interactive)
       (let* ((node (org-roam-node-read nil #'zetteldesk-node-p #'org-roam-node-sort-by-backlinks))
	      (id (org-roam-node-id node))
	      (description (org-roam-node-formatted node)))
	 (insert (org-link-make-string
		  (concat "id:" id)
		  description))))


   #+END_SRC
    
** On the zetteldesk-scratch buffer
   The zetteldesk-scratch buffer is a bit equivalent to the emacs scratch buffer. Its essentially a buffer unique to the session in which you can drop all the links, node contents or whatever else interests you and use it as the place to hold your crude notes until you drop them where they belong. I also envision this to be the buffer in which you drop all the notes you want to view at one time, in the way you would spread them on your desk.

   I am considering making a global minor mode zetteldesk-mode in which map you can put all your keybindings if you do not want the override map littered with those. It will also have a hook when turned on to create the scratch buffer. I will do this as I find it more classy to enable a minor mode than to just run the zetteldesk-create-scratch-buffer at initialization

   Things I have implemented so far
   - Creating a global minor mode for the zetteldesk.
   - Creating a function which initialises the zetteldesk-scratch buffer and hook that to the on-hook of zetteldesk-mode. The primary reason for wanting to define the minor mode was to enable it on startup and have this hook initialise the scratch buffer so I do not have to worry about it. The other reason is that for distributing this as a package I think it makes sense for it to have a minor mode in which I could possibly isolate the keybindings.
   - A function that inserts links to all the POIs in the zetteldesk to the current buffer. The way I have my zettelkasten sorted, my index files have the MOC (map of contents) tag and other important files of a subject have the POI (point of interest) tag. POIs are chosen by opening org-roam UI, blacklisting index files (in my case blacklisting the MOC tag), having a high value for "Node connections size scale" and seeing which nodes stand out the most. This is an idea taken from the book How to make a complete map of every thought you think. I use my zettelkasten for university notes and when revisioning its a great tool to be able to insert links to all POIs in some sort of scratch buffer, then sorting them and with that writing an outline of everything in that lesson. In a way, this does function as an outliner tool.
   - A function that prompts for a node inside the zetteldesk and inserts its contents to the zetteldesk-scratch buffer omitting the properties section where the id is stored. As it uses an absolute number for this, it doesn't exactly omit properties if the node has aliases or refs, I could consider trying to fix that, but I do not know how as of now. It also replaces the title keyword with a top level heading. This way you can add any node to your scratch buffer. This is equivalent to taking the note out of the drawer and putting it into your desk, the very first part of what I plan for this tool.
   - A similar function which prompts for org files in the zetteldesk but excluding org-roam files. Its behaviour is a bit different. No links are inserted as they are not needed, no part of the file is truncated as typically the first line is the title, the title is again changed to a top level heading, but as most big org files have some kind of structure to them, I also demote all their headings by 1, as their top level heading will be the title. This is part of an idea I had that this system should integrate with more than org-roam files (albeit that being the main plan) because your notes could also be in other org files.
   - A function that prompts the user to select a pdf that is part of the zetteldesk and a page in that pdf and inserts a link to that pdf, in that page. The link sits under a heading which has a specifically formatted name of the type "Supplementary Material - name_of_pdf (PDF)". Also has functionality of inserting the highlighted region of text to the zetteldesk-scratch buffer.

   Only other supportive material for any kind of work/research I could think of is source code files and browser pages. For source code files, it is in my opinion trivial to paste the code into an org mode source code block. I might automate it a bit better in the future, but for now I am not that interested in setting up something like this. For web pages, there really wouldn't be a point in inserting the web page verbatim, but only a link and some notes about it. This is already handled by org-roam protocol and that capture template of mine so if anything I will mention it and prompt to that capture template for what I think it should have. There is also screenshots and MS Office formats I guess but screenshots can be pasted into an org file from the clipboard and therefore require no automation and all MS Office formats aren't that readable in Emacs in the first place so they should be converted to pdf and handled by that imo. 

   #+BEGIN_SRC elisp :tangle zetteldesk.el

     ;; -- *ZETTELDESK-SCRATCH* --
     ;; This is the section where it all comes together. The
     ;; zetteldesk-scratch buffer is a special buffer defined here on which
     ;; you drop all your stuff. Its what molds the whole workflow together

     (defcustom zetteldesk-map (make-sparse-keymap)
       "This variable is the keymap for `zetteldesk-mode'."
       :type 'keymap
       :group 'zetteldesk)

     (defcustom zetteldesk-insert-scratch-or-current-buffer t
       "Customization variable.
     Decides whethere zetteldesk-insert functions will insert to the
     ,*zetteldesk-scratch* buffer or the current buffer.  Default value
     is t which makes those functions insert to the scratch.  Setting
     it to nil will make those functions insert to the current buffer,
     for whichever usecase you might want"
       :type 'string
       :group 'zetteldesk)

     (define-minor-mode zetteldesk-mode
       "Toggles the global zetteldesk-mode.

     When turned on, this mode initialises the *zetteldesk-scratch*
     buffer, a useful part of the whole zetteldesk workflow."
       nil
       :global t
       :group 'zetteldesk
       :keymap zetteldesk-map
       :lighter " zetteldesk")

     (defun zetteldesk--create-scratch-buffer ()
       "Create the zetteldesk-scratch buffer and put it in `org-mode'."
       (let ((buffer (generate-new-buffer "*zetteldesk-scratch*"))
	     (org-startup-with-latex-preview nil))
	 (with-current-buffer buffer
	   (org-mode))))

     (add-hook 'zetteldesk-mode-on-hook 'zetteldesk--create-scratch-buffer)

     (defmacro zetteldesk-insert-location ()
       "Find the location the zetteldesk-insert functions should insert to.

     The decision is made depending on the variable
     `zetteldesk-insert-scratch-or-current-buffer'.  Check its
     docstring for more info.  This is used in all zetteldesk-insert
     functions to decide if the insertion should happen in
     ,*zetteldesk-scratch or the current buffer."
       `(if zetteldesk-insert-scratch-or-current-buffer
		       "*zetteldesk-scratch*"
		     (current-buffer)))

     (defmacro zetteldesk-insert-switch-to-scratch (arg)
       "Switch to the *zetteldesk-scratch* if ARG is the `\\[universal-argument]'.

     All the zetteldesk-insert functions have a similar logic of
     switching to the *zetteldesk-scratch* buffer in a split if given
     a `\\[universal-argument]'.  To avoid repetition, this macro
     expands to the needed code."
       `(when (equal ,arg '(4))
	  (switch-to-buffer-other-window "*zetteldesk-scratch*")))

     (defun zetteldesk-switch-to-scratch-buffer (&optional arg)
       "Open the zetteldesk-scratch buffer in a split with the current buffer.

     Optionally, if given optional argument ARG, which needs to be the
     `\\[universal-argument]' switch to the *zetteldesk-scratch*
     buffer without issuing a split."
       (interactive "P")
       (if (equal arg '(4))
	   (switch-to-buffer "*zetteldesk-scratch*")
	 (switch-to-buffer-other-window "*zetteldesk-scratch*")))

     (defun zetteldesk-node-insert-if-poi-or-moc ()
       "Filter `org-roam-node-list' to show zetteldesk-nodes only.
     Then filter that to only those that have the POI or MOC tag with
     `zetteldesk-node-p' and `org-roam-node-poi-or-moc-p'.  Then
     insert a link to every one of those nodes and seperate them with
     commas"
       (interactive)
       (let* ((init_list (org-roam-node-list))
	      (zetteldesk_nodes (cl-remove-if-not #'zetteldesk-node-p init_list))
	      (nodes_poi (cl-remove-if-not #'org-roam-node-poi-or-moc-p zetteldesk_nodes)))
	 (while nodes_poi
	   (let* ((node (car nodes_poi))
		  (description (org-roam-node-formatted (car nodes_poi))))
	     (insert (org-link-make-string
		      (concat "id:" (org-roam-node-id (car nodes_poi)))
		      description))
	     (insert ", "))
	   (setq nodes_poi (cdr nodes_poi)))))

     (defun zetteldesk-insert-node-contents (&optional arg)
       "Select a node that is part of the current `zetteldesk'.
     Add a link to it at point and then insert its contents to the
     bottom of the *zetteldesk-scratch* buffer after inserting a
     newline there.  Remove the first 67 characters which is the
     properties section if it only contains the ID of the node as its
     unneeded and change the string #+title to a top level heading as
     its more practical when inserting the contents of multiple files.

     If given the optional argument ARG, which needs to be the
     `\\[universal-argument]' also switch to the *zetteldesk-scratch*
     buffer in a split."
       (interactive "P")
       (let* ((node (org-roam-node-read nil #'zetteldesk-node-p))
	      (file (org-roam-node-file node))
	      (description (org-roam-node-formatted node))
	      (location (zetteldesk-insert-location)))
	 (insert (org-link-make-string
		  (concat "id:" (org-roam-node-id node))
		  description))
	 (with-current-buffer location
	   (goto-char (point-max))
	   (newline)
	   (insert-file-contents file nil 67)
	   (replace-string "#+title: " "* ")))
       (zetteldesk-insert-switch-to-scratch arg))

     (defun zetteldesk-insert-node-contents-without-link ()
       "\"Sister function\" of `zetteldesk-insert-node-contents'.
     Finds a node that is part of the `zetteldesk' and inserts its
     contents to the bottom of the zetteldesk-scratch buffer. This
     function differentiates itself, by the fact that it doesn't
     insert an ID link to the node in the current buffer and by the
     fact that it switches to the scratch buffer in a split without
     needing a `\\[universal-argument]'.

     For me, it makes sense a lot of the time to insert a link to the
     node inthe current buffer, especially if its an outlining
     buffer. But sometimes its not handy, and so, I just made this
     second iteration to fix that issue."
       (interactive)
       (let* ((node (org-roam-node-read nil #'zetteldesk-node-p))
	      (location (zetteldesk-insert-location))
	      (file (org-roam-node-file node)))
	 (with-current-buffer location
	   (goto-char (point-max))
	   (newline)
	   (insert-file-contents file nil 67)
	   (replace-string "#+title: " "* ")))
       (switch-to-buffer-other-window "*zetteldesk-scratch*"))

     (defun zetteldesk-insert-org-file-contents (&optional arg)
       "Select an org buffer that is in the `zetteldesk'.
     Insert its contents to the *zetteldesk-scratch* buffer, make its
      title a top level heading and demote all of its headings by one
      level (since the title now acts as a top level heading).  Note
      that org-roam nodes are not shown

     Optional argument ARG, if given needs to be a
     `\\[universal-argument]' and it switches to the *zetteldesk-scratch*
     buffer in a split"
       (interactive "P")
       (let* ((buffer (set-buffer (read-buffer "Zetteldesk Buffers: " nil nil #'zetteldesk-org-buffer-p)))
	      (location (zetteldesk-insert-location))
	      (file (buffer-file-name buffer)))
	 (set-buffer location)
	 (goto-char (point-max))
	 (save-excursion
	   (newline)
	   (insert-file-contents file))
	 (save-excursion
	   (while (not (org-next-visible-heading 1))
	     (org-metaright)))
	 (replace-string "#+title: " "* "))
       (zetteldesk-insert-switch-to-scratch arg))

     (defun zetteldesk-insert-link-to-pdf (&optional arg)
       "Select a pdf file that is part of the `zetteldesk'.
     Prompt for a page in that pdf (defaults to page 1 if you don't
     care about the page).

     Then, in the zetteldesk-scratch buffer, insert at `point-max' a
     newline and then a new heading with its name consisting of the
     string \"Supportive Material - \" then the pdfs name, without the
     file structure or the extension and then the string
     \"(PDF)\".  Then, insert a newline, the string \"Link to PDF: \"
     and then a link to the chosen pdf, in the correct page, with the
     description being the pdfs name without the file structure or the
     extension.  Note that `org-pdftools-setup-link' needs to be run
     for pdf links to work (which this uses).

     Optionally, if given optional argument ARG which is the
     `\\[universal-argument]' save the highlighted region in a
     variable and insert it after the heading but before the pdf link.
     This functionality serves the purpose of adding a \"description\"
     sort of thing to the pdf. Typically, when citing a pdf as
     supplementary info to an argument, there is something specific
     you want to take from the pdf. Therefore, this optional addition,
     adds that to the scratch buffer so you remember why it was
     useful."
       (interactive "P")
       (let* ((pdf-buffer (set-buffer (read-buffer "Zetteldesk Pdfs: " nil nil #'zetteldesk-pdf-p)))
	      (file (buffer-file-name pdf-buffer))
	      (location (zetteldesk-insert-location))
	      (page (read-from-minibuffer "Page: " "1"))
	      (description (file-name-nondirectory (file-name-sans-extension file))))
	 (with-current-buffer location
	   (goto-char (point-max))
	   (newline)
	   (org-insert-heading)
	   (insert "Supportive Material - " description " (PDF)")
	   (newline)
	   (when (equal arg '(4))
	     (let ((contents (buffer-substring (mark) (point))))
	       (insert contents)
	       (newline)))
	   (insert "Link to PDF: "
		   (org-link-make-string
		    (concat "pdf:" file "::" page)
		    description)))))


   #+END_SRC

   #+RESULTS:
   : zetteldesk-insert-info-contents

** Org-remark integration
   Org-remark is a package for highlighting parts of a document and creating marginal notes from them. I believe that such a feature is great for an environment such as the zetteldesk-scratch buffer. But as that buffer is not associated to a file, I want to setup better integration between it and zetteldesk.

   Namely, I am mostly looking for two things to work as I want them. Be able to create margin notes from the zetteldesk-scratch buffer without it being associated to a file, by let-binding the value of ~org-remark-notes-file-name~ to an absolute path, probably of the form of org-roam-directory/zetteldesk-margin-notes.org or something. Then, if I decide I want to save this zetteldesk to a file, the margin-notes should be linked there correctly (might happen by default, however I am uncertain).

   Furthermore, I want to make sure the behaviour is as intended when having multiple margin notes from zetteldesks. This heading will tangle to a seperate file which will be a zetteldesk extension.

   #+BEGIN_SRC elisp :tangle zetteldesk-remark.el

     (defun zetteldesk-remark-mark (beg end)
       "Wrapper for `org-remark-mark'.

     Calls the function with `org-remark-notes-file-name' being set to
     zetteldesk-margin-notes.org in the `org-roam-directory'"
       (interactive (org-remark-region-or-word))
       (let ((org-remark-notes-file-name
	      (concat org-roam-directory "zetteldesk-margin-notes.org")))
	 (org-remark-mark beg end)))

     (defun zetteldesk-remark-highlight-advice
	 (beg end &optional id mode label face properties)
       "Advice function to be used with `org-remark-highlight-mark'.

     If the current buffer isn't associated to a file, find the
     heading's title, associate it with an org-roam-node and find the
     file associated with that node. Then run the part of
     `org-remark-highlight-save' that wasn't ran if the buffer isn't
     associated with a file. This part is a call to
     `org-remark-highlight-save'.

     This is meant to be used when taking margin notes from the
     ,*zetteldesk-scratch* buffer. However, this will only work if the
     current heading's title is associated with a node. In this case
     org-remark will be able to associate the margin note with the
     node its related to."
       (unless buffer-file-name
	 (let* ((title (org-entry-get nil "ITEM"))
		(node (org-roam-node-from-title-or-alias title))
		(file (org-roam-node-file node))
		(ov (make-overlay beg end nil :front-advance)))
	   (org-remark-highlight-save file
				      beg end
				      (overlay-properties ov)
				      title))))

     (advice-add 'org-remark-highlight-mark :after #'zetteldesk-remark-highlight-advice)

     (defun zetteldesk-switch-to-margin-notes ()
       "Helper function which goes to the zetteldesk-margin-notes file.

     If `org-remark-mark' is called through its wrapper function
     `zetteldesk-remark-mark', it sets `org-remark-notes-file-name' to
     a specific file, which is meant to be used with all margin notes
     coming from zetteldesk-scratch. This function switches to that
     file."
       (interactive)
       (pop-to-buffer (find-file (concat org-roam-directory "zetteldesk-margin-notes.org"))))

   #+END_SRC
     
** Handling notes on articles better
   This section is about zetteldesk-ref, an optional extension of zetteldesk.el. It includes integrationof the zetteldesk with various reference sources such as bibtex entry nodes, which are org-roam nodes, however they need a different behaviour than your typical org-roam node. It also include the info stuff as I decided to make that optional.

*** Preamble
    This is just the intro text that needs to be in the start of the file

    #+BEGIN_SRC elisp :tangle zetteldesk-ref.el
      ;;; zetteldesk-ref.el --- A zetteldesk extension for use with the Info
      ;;; program and literature nodes

      ;; Author: Vidianos Giannitsis <vidianosgiannitsis@gmail.com>
      ;; Maintaner: Vidianos Giannitsis <vidianosgiannitsis@gmail.com>
      ;; URL: https://github.com/Vidianos-Giannitsis/zetteldesk-ref.el
      ;; Package-Requires: ((zetteldesk "0.2") (bibtex-completion))
      ;; Created: 27th March 2022
      ;; License: GPL-3.0

      ;; This file is free software; you can redistribute it and/or modify
      ;; it under the terms of the GNU General Public License as published by
      ;; the Free Software Foundation; either version 3, or (at your option)
      ;; any later version.

      ;; This program is distributed in the hope that it will be useful,
      ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
      ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      ;; GNU General Public License for more details.

      ;; For a full copy of the GNU General Public License
      ;; see <https://www.gnu.org/licenses/>.

      ;;; Commentary:

      ;; This package provides some optional improvements to
      ;; zetteldesk.el. Specifically it introduces mechanisms for handling
      ;; nodes from the Info program built in to emacs and literature notes
      ;; associated to a bibtex entry which are mostly powered by
      ;; org-noter. This code makes these reference materials interface
      ;; better with the zetteldesk.

      ;;; Code:

    #+END_SRC
    
*** Reference notes from Bibtex Entries
    I have a decent amount of notes that are on scientific articles taken with ~org-noter~. These are org-roam nodes, but they need a special behaviour imo as their formatting isn't similar to that of my permanent notes. Now, gathering these nodes to make a special filter function including only those was an adventure in and of itself. But it was a chance to get more familiarized with common lisp loops, which are a very powerful system.

   #+BEGIN_SRC elisp :tangle zetteldesk-ref.el

     ;; -- Reference Nodes from Bibtex Entries --
     (defun zetteldesk-note-refs-p ()
       "Predicate function that finds all bibtex completion candidates with a note.

     Checks if every candidate has the \"=has-note=\" tag using
     `assoc' and if it does, collects that candidate"
       (cl-loop for ref in (bibtex-completion-candidates)
		if (assoc "=has-note=" ref)
		collect ref))

     (defun zetteldesk-citekey-from-refs ()
       "Function that finds the \"=key=\" tag from a list of candidates.

     The list is collected with `zetteldesk-note-refs-p' which is a
     list of candidates that have notes. Collects it using `assoc'."
       (cl-loop for ref in (zetteldesk-note-refs-p)
		collect (assoc "=key=" ref)))

     (defun zetteldesk-node-from-refs ()
       "Function that collects a list of ref nodes.

     The nodes are collected from their citekey using
     `org-roam-node-from-ref', while the citekeys themselves are
     collected from `zetteldesk-citekey-from-refs'."
       (cl-loop for ref in (zetteldesk-citekey-from-refs)
		collect (org-roam-node-from-ref (concat "cite:" (cdr ref)))))

     (defun org-roam-node-read--completions* (node-list &optional filter-fn sort-fn)
       "Runs `org-roam-node-read--completions' with NODE-LIST being a list of nodes.

     Typically, the function takes `org-roam-node-list' as the initial
     list of nodes and creates the alist `org-roam-node-read'
     uses. However, it can be helpful to supply the list of nodes
     yourself, when the predicate function used cannot be inferred
     through a filter function of the form this function
     takes. FILTER-FN and SORT-FN are the same as in
     `org-roam-node-read--completions'. The resulting alist is to be
     used with `org-roam-node-read*'."
       (let* ((template (org-roam-node--process-display-format org-roam-node-display-template))
	      (nodes node-list)
	      (nodes (mapcar (lambda (node)
			       (org-roam-node-read--to-candidate node template)) nodes))
	      (nodes (if filter-fn
			 (cl-remove-if-not
			  (lambda (n) (funcall filter-fn (cdr n)))
			  nodes)
		       nodes))
	      (sort-fn (or sort-fn
			   (when org-roam-node-default-sort
			     (intern (concat "org-roam-node-read-sort-by-"
					     (symbol-name org-roam-node-default-sort))))))
	      (nodes (if sort-fn (seq-sort sort-fn nodes)
		       nodes)))
	 nodes))

     (defun org-roam-node-read* (node-list &optional initial-input filter-fn sort-fn require-match prompt)
       "Runs `org-roam-node-read' with the nodes supplied by NODE-LIST.

     NODE-LIST is a list of nodes passed to
     `org-roam-node-read--completions*', which creates an alist of
     nodes with the proper formatting to be used in this
     function. This is for those cases where it is helpful to use your
     own list of nodes, because a predicate function can not filter
     them in the way you want easily."
       (let* ((nodes (org-roam-node-read--completions* node-list filter-fn sort-fn))
	      (prompt (or prompt "Node: "))
	      (node (completing-read
		     prompt
		     (lambda (string pred action)
		       (if (eq action 'metadata)
			   `(metadata
			     ;; Preserve sorting in the completion UI if a sort-fn is used
			     ,@(when sort-fn
				 '((display-sort-function . identity)
				   (cycle-sort-function . identity)))
			     (annotation-function
			      . ,(lambda (title)
				   (funcall org-roam-node-annotation-function
					    (get-text-property 0 'node title))))
			     (category . org-roam-node))
			 (complete-with-action action nodes string pred)))
		     nil require-match initial-input 'org-roam-node-history)))
	 (or (cdr (assoc node nodes))
	     (org-roam-node-create :title node))))

     (defun zetteldesk-find-ref-node ()
       "Execute a filtered version of `ivy-bibtex-with-notes'.

     This does not exactly run `ivy-bibtex-with-notes' as that doesn't
     have a way to filter things. It collects a list of nodes which
     are reference nodes linked to a bibtex entry through
     `zetteldesk-node-from-refs' and passes it to
     `org-roam-node-read*' which is a modified version of
     `org-roam-node-read' which takes a list of nodes as an
     argument. Since this required a rewrite of `org-roam-node-read',
     finding the file is done indirectly and not through
     `org-roam-node-file'."
       (interactive)
       (find-file (org-roam-node-file (org-roam-node-read* (zetteldesk-node-from-refs) nil #'zetteldesk-node-p))))

     (defun zetteldesk-insert-ref-node-contents (&optional arg)
       "Select a node that is part of the current `zetteldesk' and a ref node.
     Ref nodes are nodes that refer to reference material such as an
     article. These are gathered with `zetteldesk-node-from-refs' and
     shown to the user through `org-roam-node-read*' filtered
     according to `zetteldesk-node-p'.

     After selection, insert its citekey at point for future
     reference, then in the location determined by
     `zetteldesk-insert-location' (typically *zetteldesk-scratch*), go
     to `point-max', insert a newline and then insert the contents of
     the selected node but remove the first 4 lines which is the
     unneeded property drawer. After, indent all headings by one level
     and replace the #+title: with an asterisk. Finally, enter a
     newline after the title, where the string \"Bibtex entry for
     node: \" is entered suffixed by the citekey of the entry.

     If given the optional argument ARG, which needs to be the
     `\\[universal-argument]' also switch to the *zetteldesk-scratch*
     buffer in a split."
       (interactive "P")
       (let* ((node
	       (org-roam-node-read* (zetteldesk-node-from-refs) nil #'zetteldesk-node-p))
	      (file (org-roam-node-file node))
	      (location (zetteldesk-insert-location))
	      (citekey (concat "cite:" (car (org-roam-node-refs node)))))
	 (insert citekey)
	 (set-buffer location)
	 (goto-char (point-max))
	 (save-excursion
	   (insert-file-contents file))
	 (kill-whole-line 4)
	 (newline)
	 (save-excursion
	   (while (not (org-next-visible-heading 1))
	     (org-metaright)))
	 (replace-string "#+title: " "* ")
	 (end-of-line 1)
	 (newline)
	 (insert "Bibtex entry for node: "
		 citekey))
       (zetteldesk-insert-switch-to-scratch arg))

   #+END_SRC

*** Info Nodes
    The info buffer is a single persistent buffer. Therefore, the typical things done in the zetteldesk don't work here. This section is an attempt to fix this and use info nodes together with zetteldesk. There is a function that gives the nodes name in a format that all other Info functions accept. I use that function and add the nodes selected to a variable. The rest of the functions, choose something from that list with completing-read and that is how this system works. For example, the removing mechanisms works by using remove with its argument being the output of the completing-read. The insertion function is a function that prompts the user to select an info buffer that is part of the zetteldesk and inserts its contents to the zetteldesk-scratch buffer under a similarly to above formatted heading. Furthermore, it inserts a link to the info node so you can see it in its context. 

    #+BEGIN_SRC elisp :tangle zetteldesk-ref.el

      ;; -- Info Nodes --
      (defcustom zetteldesk-info-nodes '()
	"List of info nodes that are part of the zetteldesk.
      Initialised as an empty list"
	:type 'list
	:group 'zetteldesk)

      (defun zetteldesk-add-info-node-to-desktop ()
	"Find the current info-node.
      Then add its name to the list of the variable
      `zetteldesk-info-nodes'"
	(interactive)
	(add-to-list 'zetteldesk-info-nodes (Info-copy-current-node-name)))

      (defun zetteldesk-remove-info-node-from-desktop ()
	"Remove an info-node from the `zetteldesk'.
      The node is selected through a `completing-read' menu of
      `zetteldesk-info-nodes'"
	(interactive)
	(setq zetteldesk-info-nodes (remove
				     (completing-read "Info Nodes: " zetteldesk-info-nodes)
				     zetteldesk-info-nodes)))

      (defun zetteldesk-info-goto-node ()
	"Zetteldesk filter function for `Info-goto-node'.

      Prompts the user to select a node from the list
      `zetteldesk-info-nodes' and jumps to that node"
	(interactive)
	(Info-goto-node (completing-read "Nodes: " zetteldesk-info-nodes)))

      (defun zetteldesk-insert-info-contents (&optional arg)
	"Select an info node that is part of the current `zetteldesk'.
      Uses a `completing-read' prompt for the selection.

      Then, in the *zetteldesk-scratch* buffer, go to the end of the
      buffer, insert a newline and a heading of the form \"Supportive
      Material - \" the node's name \"(Info)\" akin to what is done in
      `zetteldesk-insert-link-to-pdf'.  Then, insert the contents of the
      chosen info node, removing the first 2 lines which have the
      contextual links of the buffer, as they are not functional
      outside of the info buffer.  Also insert a link with the title
      \"See this node in its context\" which opens the node inside the
      info program. Finally, restore the buffer from which this
      function was called. Ideally, this wouldn't require a
      switch-to-buffer statement, but the function `Info-goto-node'
      used for this function switches the visible buffer to the info
      node and I couldn't find an alternative that only makes it
      current for editing operations, but doesn't change the visible
      buffer to it.

      I find the link to the actual info buffer is useful as a lot of
      the time, you might want to insert the buffer so you can store it
      with other useful information inside the zetteldesk-scratch
      buffer, but then, you are interested in looking into the other
      nodes of the manual you were reading.

      Optional argument ARG which is a `\\[universal-argument]' switch to the
      zetteldesk-scratch buffer in a split."
	(interactive "P")
	(let ((info_node (completing-read "Nodes: " zetteldesk-info-nodes))
	      (location (zetteldesk-insert-location))
	      (buffer (current-buffer)))
	  (Info-goto-node info_node)
	  (with-current-buffer location
	    (goto-char (point-max))
	    (newline)
	    (org-insert-heading)
	    (insert "Supportive Material - " info_node " (Info)")
	    (newline)
	    (save-excursion (insert-buffer-substring "*info*")
			    (insert
			     (org-link-make-string
			      (concat "elisp:(Info-goto-node \"" info_node "\")")
			      "See this node in its context")))
	    (kill-whole-line 2))
	  (switch-to-buffer buffer)
	  (zetteldesk-insert-switch-to-scratch arg)))

    #+END_SRC


* Providing the packages to be loaded in init.el
#+BEGIN_SRC elisp :tangle zetteldesk.el

  (provide 'zetteldesk)
  ;;; zetteldesk.el ends here

#+END_SRC
  
#+BEGIN_SRC elisp :tangle zetteldesk-ref.el

  (provide 'zetteldesk-ref)
  ;;; zetteldesk-ref.el ends here

#+END_SRC

  #+BEGIN_SRC elisp :tangle yes

    (provide 'zettelkasten)

  #+END_SRC
  
