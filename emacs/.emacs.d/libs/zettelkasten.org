#+TITLE: Org-Roam, References and the Zettelkasten Workflow

This file is a core part of my emacs configuration and is all about my Org-roam setup and my reference management inside org. Its based on the Zettelkasten method and the Roam Research website. Notes are linked with one another. Bibtex completion (and the existence of .bib files in general) as well as Org-ref help manage bibliographic references inside org. I also use Zotero as it easily allows me to gather my bibliographies. It exports a .bib file which these two use. Org Roam Bibtex (ORB) is a package that combines all of these to help you add citation links from org-ref inside an org-roam buffer. This section includes all the customisations and settings of these packages. This is a very large section of my config (hence why it has its own file) as I have really customised this workflow a lot. 

* Table of Contents                                                     :TOC:
- [[#org-roam-general-setup][Org-Roam general setup]]
- [[#useful-functions][Useful Functions]]
- [[#acting-on-backlinks][Acting on backlinks]]
- [[#bibtex-completion-ivy-and-org-ref][Bibtex completion (Ivy) and Org-Ref]]
- [[#org-roam-bibtex-protocols-reference-notes-and-ui-graphing-capabilities][Org Roam Bibtex, Protocols (Reference notes) and UI (graphing capabilities)]]
- [[#logseq-like-tagging-functionality][Logseq-like tagging functionality]]
- [[#fleeting-notes][Fleeting notes]]
- [[#capture-templates][Capture Templates]]
- [[#providing-the-packages-to-be-loaded-in-initel][Providing the packages to be loaded in init.el]]

* Org-Roam general setup
  This part is the general setup of org-roam. It contains the setup, removing the warning message for the migration to v2, and the use-package declaration for org-roam. There I put the org roam directory, the various defmethods I use, my display template and a resize to the org-roam buffer as taking half the screen isn't something I like. I much prefer it to be a bit smaller than the main window.

  A lot of the defmethods defined here are for my display template as I think its useful to see directories, backlink count and todo state of nodes in the org-roam-node-find UI. Then there is the oddball org-roam-node-backlinkscount-number which is identical almosy to org-roam-node-backlinkscount, but its different output is useful for a function I define later and the org-roam-node-buffer defmethod which is a very helpful defmethod that imo should have been defined in org-roam. It returns the buffer associated to a node, and nil if there is none. I use this in various parts of my config and I consider it an important defmethod. 
   
 #+BEGIN_SRC elisp :tangle yes

   (add-hook 'after-init-hook 'org-roam-setup)
   (setq org-roam-v2-ack t)

   (use-package org-roam
     :config
     (setq org-roam-directory "~/org_roam/"
	   org-roam-dailies-directory "~/org_roam/daily")

     (cl-defmethod org-roam-node-directories ((node org-roam-node))
       "Access slot \"directory\" of org-roam-node struct CL-X"
       (if-let ((dirs (file-name-directory (file-relative-name (org-roam-node-file node) org-roam-directory))))
	   (format "(%s)" (car (f-split dirs)))
	 ""))

     (cl-defmethod org-roam-node-backlinkscount ((node org-roam-node))
       "Access slot \"backlinks\" of org-roam-node struct CL-X"
       (let* ((count (caar (org-roam-db-query
			    [:select (funcall count source)
				     :from links
				     :where (= dest $s1)
				     :and (= type "id")]
			    (org-roam-node-id node)))))
	 (format "[%d]" count)))

     (cl-defmethod org-roam-node-backlinkscount-number ((node org-roam-node))
       "Access slot \"backlinks\" of org-roam-node struct CL-X. This
       is identical to `org-roam-node-backlinkscount' with the
       difference that it returns a number instead of a fromatted
       string. This is to be used in
       `org-roam-node-sort-by-backlinks'"
       (let* ((count (caar (org-roam-db-query
			    [:select (funcall count source)
				     :from links
				     :where (= dest $s1)
				     :and (= type "id")]
			    (org-roam-node-id node)))))
	 count))

     (cl-defmethod org-roam-node-todostate ((node org-roam-node))
       "Modified version of org-roam-node-todo to look a bit better"
       (if-let ((state (org-roam-node-todo node)))
	   (format "Status: %s" state)))

     (cl-defmethod org-roam-node-buffer ((node org-roam-node))
       "Access slot \"buffer\" of org-roam-node struct CL-X"
       (let ((buffer (get-file-buffer (org-roam-node-file node))))
	 buffer))

     (setq org-roam-node-display-template "${title:100} ${backlinkscount:6} ${todostate:20} ${directories:10} ${tags:25}")

     (add-to-list 'display-buffer-alist
		  '("\\*org-roam\\*"
		    (display-buffer-in-direction)
		    (direction . right)
		    (window-width . 0.40)
		    (window-height . fit-window-to-buffer))))

   #+END_SRC

* Useful Functions
   Org roam is a cornerstone of my workflow (which is the reason this file is so stupidly large). I have written various "helper" functions for my own assistance that are meant to be used with org-roam. This section includes those functions. They are all documented well so I do not think I need to describe them. 

#+BEGIN_SRC elisp :tangle yes

  (defun org-roam-buffer-without-latex ()
      "Essentially `org-roam-buffer-toggle' but it ensures latex previews are turned off before toggling the buffer.

    This is useful because especially with index files, having
    latex previews on, makes opening the buffer very slow as it
    needs to load previews of many files. If you by default have
    `org-startup-with-latex-preview' set to t, you have probably
    noticed this issue before. This function solves it."
      (interactive)
      (let ((org-startup-with-latex-preview nil))
	(org-roam-buffer-toggle)))

  (defun org-roam-permanent-note-p (NODE)
    "Check if NODE is at the top level org_roam directory using the
    `org-roam-node-directories' function. If it isn't,
    `org-roam-node-directories' will return a non empty string,
    therefore this expression will evaluate to nil. The way my
    notes are sorted, when a note is placed on the top level its a
    permanent note, while fleeting and reference notes are placed
    in subdirectories.

  Therefore, this predicate function allows me to create a version
  of `org-roam-node-find' which only shows my permanent notes,
  which can be useful in some cases. That filtered function is
  `org-roam-find-permanent-node'."
    (string-equal (org-roam-node-directories NODE) ""))

  (defun org-roam-node-poi-or-moc-p (NODE)
    "Check if NODE has the tag POI or the tag MOC. Return t if it does"
    (or (string-equal (car (org-roam-node-tags NODE)) "POI")
	(string-equal (car (org-roam-node-tags NODE)) "MOC")))

  (defun org-roam-find-permanent-node ()
    "Execute `org-roam-node-find' with the list being filtered to
  only include permanent notes. In my system that is synonymous to
  saying include only notes at the top level directory. The
  filtering is done with the `org-roam-permanent-note-p' predicate
  function."
    (interactive)
    (org-roam-node-find nil nil #'org-roam-permanent-note-p))
#+END_SRC

* Acting on backlinks
  Backlinks are a pivotal part of this workflow. A file has a backlink if another file links to it. As a core part of my workflow revolves around index files (or Maps of Contents) and those are files that basically everything connected to that subject links to them, they end up being files with a lot of backlinks. I have some functions here that act on backlinks which I consider useful. Excluded from this list are two defmethods I use concerning backlinks as I define all my defmethods in the first part of the config.

  The first is org-roam-node-backlinkscount, a function I initially found on the OR wiki on github, which finds the number of backlinks a note has and formats them in a nice string. Its meant to be used with org-roam-node-display-template to show the number of backlinks in the org-roam-node-UI. The second is an almost identical function, but instead of returning a formatted string it returns a number. That is meant to be used with org-roam-node-sort-by-backlinks, a function defined below which sorts nodes by the number of backlinks they have. Number comparison is much easier than comparison of string representing numbers, and due to the extra formatting applied (which I like for the purpose that function has) I couldn't find how to convert that string to a number so I just made a rewrite with that small change.  

  #+BEGIN_SRC elisp :tangle yes

    (defvar-local org-roam-backlinks nil
      "Buffer local variable displaying a list of the absolute paths
      of all the files that are backlinked to current node. These are
      not added by default, and as such this variable has the value
      nil but they can be added by running the
      `org-roam-backlink-files' function on a node.")

    (defvar org-roam-backlink-pdfs nil
      "After running `org-roam-export-backlinks-to-latex-pdf', to
      export a node and all its backlinks to pdf, the value of this
      variable in the original node's buffer will become a list of
      all the pdfs that were created. This is to ease the process of
      combining them as the value of this variable can then be passed
      to a program such as pdftk to combine them.")

    (defun org-roam-node-sort-by-backlinks (completion-a completion-b)
      "Sorting function for org-roam that sorts the list of nodes by
    the number of backlinks. This is the sorting function in
    `org-roam-node-find-by-backlinks'"
      (let ((node-a (cdr completion-a))
	    (node-b (cdr completion-b)))
	(>= (org-roam-node-backlinkscount-number node-a)
	    (org-roam-node-backlinkscount-number node-b))))

    (defun org-roam-node-find-by-backlinks ()
      "Essentially works like `org-roam-node-find' (although it uses
    a combination of `find-file' and `org-roam-node-read' to
    accomplish that and not `org-roam-node-find' as only
    `org-roam-node-read' can take a sorting function as an argument)
    but the list of nodes is sorted by the number of backlinks
    instead of most recent nodes. Sorting is done with
    `org-roam-node-sort-by-backlinks'"
      (interactive)
      (find-file (org-roam-node-file (org-roam-node-read nil nil #'org-roam-node-sort-by-backlinks))))

    (defun org-roam-backlinks-query ()
      "Simple org-roam query function that stores the IDs of all the
      files that link to the node at point. This is a modified part
      of the `org-roam-backlinks-get' function keeping only the part
      necessary for `org-roam-backlink-files' to work as this is a
      complimentary function to that"
      (org-roam-db-query
       [:select [source dest]
		:from links
		:where (= dest $s1)
		:and (= type "id")]
       (org-roam-node-id (org-roam-node-at-point))))

    (defun org-roam-backlink-files ()
	"Get all nodes that link to the node at point with the
	`org-roam-backlink-query' function, find their absolute path
	and save a list of those paths to the buffer local variable
	`org-roam-backlinks'.

      With the list, you can act on all those files together. This is
      exceptionally useful with index files as it allows you to do an
      action on all files linked to this index automatically."
	(interactive)
	(let ((backlinks (length (org-roam-backlink-query))))
	  (dotimes (number backlinks)
	    (let* ((id (car (nth number (org-roam-backlink-query))))
		   (node (org-roam-node-from-id id)))
	      (setq-local org-roam-backlinks (cons (org-roam-node-file node) org-roam-backlinks))))
	  org-roam-backlinks))

    (defun org-roam-export-backlinks-to-latex-pdf ()
      "Export the current buffer and every buffer that mentions it to
    a pdf through the org-latex export. Makes use of the
    `org-roam-backlink-files' function to find all the
    backlinks. Also saves all the pdf names in a variable called
    `org-roam-backlink-pdfs'. These names can then be passed to
    something like pdftk to merge them into one pdf"
      (interactive)
      (save-current-buffer
	(let ((backlinks (cons (buffer-file-name) org-roam-backlinks))
	      (org-startup-with-latex-preview nil))
	  (while backlinks
	    (find-file (car backlinks))
	    (org-latex-export-to-pdf)
	    (setq org-roam-backlink-pdfs
		  (cons (concat (file-name-sans-extension (car backlinks)) ".pdf") org-roam-backlink-pdfs))
	    (setq backlinks (cdr backlinks)))))
      (message "%s" "Done!"))

  #+END_SRC

** Org-roam-backlinks-search
This section is about a small "package" I recently wrote. Its a backlink selector functionality for org-roam. I thought it was a neat idea to be able to navigate from one node to its backlinks and repeat recursively so I wrote this code for it. Once I polish it further, I might release some of this to MELPA. For now it will stay here.

#+BEGIN_SRC elisp :tangle yes

  (defcustom org-roam-backlinks-choices '("View Backlinks" "Go to Node" "Quit")
    "List of choices for `org-roam-backlinks-node-read'.")

  (defun org-roam-backlinks-query* (NODE)
    "Gets the backlinks of NODE with `org-roam-db-query'."
    (org-roam-db-query
	  [:select [source dest]
		   :from links
		   :where (= dest $s1)
		   :and (= type "id")]
	  (org-roam-node-id NODE)))

  (defun org-roam-backlinks-p (SOURCE NODE)
    "Predicate function that checks if NODE is a backlink of SOURCE."
    (let* ((source-id (org-roam-node-id SOURCE))
	   (backlinks (org-roam-backlinks-query* SOURCE))
	   (id (org-roam-node-id NODE))
	   (id-list (list id source-id)))
      (member id-list backlinks)))

  (defun org-roam-backlinks-poi-or-moc-p (NODE)
    "Check if NODE has the tag POI or the tag MOC.  Return t if it does."
    (or (string-equal (car (org-roam-node-tags NODE)) "POI")
	(string-equal (car (org-roam-node-tags NODE)) "MOC")))

  (defun org-roam-backlinks--read-node-backlinks (source)
    "Runs `org-roam-node-read' on the backlinks of SOURCE.
  The predicate used as `org-roam-node-read''s filter-fn is
  `org-roam-backlinks-p'."
    (org-roam-node-read nil (apply-partially #'org-roam-backlinks-p source)))

  (defun org-roam-backlinks-node-read (node)
    "Read a NODE and run `org-roam-backlinks--read-node-backlinks'.
  Upon selecting a backlink, prompt the user for what to do with
  the backlink. The prompt is created with `completing-read' with
  valid options being everything in the list
  `org-roam-backlinks-choices'.

  If the user decides to view the selected node's backlinks, the
  function recursively runs itself with the selection as its
  argument. If they decide they want to go to the selected node,
  the function runs `find-file' and the file associated to that
  node. Lastly, if they choose to quit, the function exits
  silently."
    (let* ((backlink (org-roam-backlinks--read-node-backlinks node))
	   (choice (completing-read "What to do with NODE: "
				    org-roam-backlinks-choices)))
      (cond
       ((string-equal
	 choice
	 (car org-roam-backlinks-choices))
	(org-roam-backlinks-node-read backlink))
       ((string-equal
	 choice
	 (cadr org-roam-backlinks-choices))
	(find-file (org-roam-node-file backlink)))
       ((string-equal
	 choice
	 (caddr org-roam-backlinks-choices))))))

  (defun org-roam-backlinks-search ()
    "Select an `org-roam-node' and recursively search its backlinks.

  This function is a starter function for
  `org-roam-backlinks-node-read' which gets the initial node
  selection from `org-roam-node-list'. For more information about
  this function, check `org-roam-backlinks-node-read'."
    (interactive)
    (let ((node (org-roam-node-read)))
      (org-roam-backlinks-node-read node)))

  (defun org-roam-backlinks-search-from-moc-or-poi ()
    "`org-roam-backlinks-search' with an initial selection filter.

  Since nodes tagged as \"MOC\" or \"POI\" are the entry points to
  my personal zettelkasten, I have this helper function which is
  identical to `org-roam-backlinks-search' but filters initial
  selection to only those notes. That way, they initial selection
  has a point as it will be on a node that has a decent amount of
  backlinks."
    (interactive)
    (let ((node (org-roam-node-read nil #'org-roam-backlinks-poi-or-moc-p)))
      (org-roam-backlinks-node-read node)))

#+END_SRC
  
* Bibtex completion (Ivy) and Org-Ref
  Ivy Bibtex and Org ref are two excellent packages for managing bibliography. The main thing I need to configure is the location of my master .bib file and pdfs (which are exported with Zotero). I also change some other variables where I see fit.
   
  In detail
  - Zotero exports a .bib file with all my references (the main way it "talks" to Emacs). I "tell" ivy-bibtex and org-ref the location of this file for usage in their various commands.
  - I allow ivy-bibtex to query by keywords or abstract. Can be useful
  - I make the default action of ivy-bibtex, the edit notes action. Personally, its the action I use most as opening the link/pdf to the reference (which is the original default) is more easily done from Zotero imo. In Emacs I find more utility in this function creating bibliographical notes.
  - Since opening the pdf, url or DOI of a bibtex entry is no longer the default action in my config, I bind it to the letter p in the options menu of Ivy-bibtex
  - Change the citation format bibtex uses on org mode. I enter cite links with org-ref-insert-cite-links so I make the ivy-bibtex link be a link to the pdf.

     #+BEGIN_SRC elisp :tangle yes
       (setq bibtex-completion-bibliography
	     '("~/Sync/My_Library.bib" "~/Sync/My_Library2.bib")
	     bibtex-completion-pdf-field "File"
	     bibtex-completion-library-path '("~/Sync/Zotero_pdfs"))
	
       (setq bibtex-completion-additional-search-fields '(keywords abstract))
	
       (setq ivy-bibtex-default-action 'ivy-bibtex-edit-notes)
       (ivy-add-actions
	'ivy-bibtex
	'(("p" ivy-bibtex-open-any "Open pdf, url or DOI")))
	
       (setq bibtex-completion-format-citation-functions
	     '((org-mode . bibtex-completion-format-citation-org-title-link-to-PDF)
	       (latex-mode . bibtex-completion-format-citation-cite)
	       (markdown-mode . bibtex-completion-format-citation-pandoc-citeproc)
	       (python-mode . bibtex-completion-format-citation-sphinxcontrib-bibtex)
	       (rst-mode . bibtex-completion-format-citation-sphinxcontrib-bibtex)
	       (default . bibtex-completion-format-citation-default)))
    #+END_SRC

** Citar
The bibliography backend I currently use is ivy-bibtex (hence the above config). However, I have experimented with Citar for porting my package ~zetteldesk-ref~ to use it as a backend besides ivy-bibtex and honestly its a pretty neat package. I am considering moving to it as its a very nice and definitely super active project. This section holds my basic configurations for it which are for now at least only defining the paths to the bibliography and notes.

#+BEGIN_SRC elisp :tangle yes

  (setq citar-bibliography '("~/Sync/My_Library.bib" "~/Sync/My_Library2.bib"))
  (setq citar-notes-paths '("~/org_roam/ref"))

#+END_SRC
  
* Org Roam Bibtex, Protocols (Reference notes) and UI (graphing capabilities)
   I require a bunch of packages so ORB, org roam ui and the roam protocols work as intended. I also make orb use ivy for completions.

   For a brief description of each ones use case, org-roam-bibtex (aka ORB) is an excellent package for bibliography management inside org-roam. Since other packages help out with this, the big thing this one does is that it hooks bibtex-completion to use the org-roam ecosystem for its notes. Org-protocol is for capturing info from a web page and adding it to an org file. The org-roam-protocol is basically integrating that to the org-roam ecosystem. Org-roam-ui is the new graphing package designed for org-roam-v2. We used to use org-roam-server for this, but with the migration to v2, this package was created (which is honestly better than org-roam-server) for an excellent visual graph of your org roam directory. There are many advantages to viewing your knowledge repository with a graph so this is a must have package. 

#+BEGIN_SRC elisp :tangle yes
  
  (require 'org-roam-bibtex)
  (org-roam-bibtex-mode 1)
  
  (setq orb-insert-interface 'ivy-bibtex
	orb-note-actions-interface 'ivy)
  (setq orb-preformat-keywords '("citekey" "author" "date" "entry-type" "keywords" "url" "file"))
  
  (require 'org-protocol)
  (require 'org-roam-protocol)
  
  (require 'websocket)
  (require 'org-roam-ui)
  
#+END_SRC

* Logseq-like tagging functionality
  I recently had a [[https://www.reddit.com/r/orgmode/comments/tgb7f9/orgroam_journey/i17ohct/?context=3][discussion]] with a fellow redditor on r/orgmode about how to get some useful features logseq has in org-roam. Especially, he told me how logseq handles tags and some useful features they have. Intrigued by the idea, I decided I could try and implement it to org-roam as a fun little project. It didn't sound so hard so I was like, sure why not. Here's the result I got. I don't even know if I am going to use this, but it can stay here for now. Note that it relies on org-transclusion to do a lot of the work. 

  #+BEGIN_SRC elisp :tangle zettelkasten.el

    (defun org-roam-node-sort-by-atime (NODE1 NODE2)
      "Sorting function that sorts NODE1 and NODE2 by their file atime.

    This is a simplified version of
    `org-roam-node-read-sort-by-file-atime' which requires nodes as
    its input and not something else. The above function is what
    `org-roam-node-read's sorting uses and it has a special
    formatting."
      (time-less-p (org-roam-node-file-atime NODE1)
		   (org-roam-node-file-atime NODE2)))

    (defun org-roam-logseq-tag-function (TAG)
      "An implementation of logseq's tagging system in org-roam.

    Prompt for TAG which is the name of a tag in your org-roam
    repository, filter it to only contain nodes with that tag and
    sort them so the most recently accessed one is the first item of
    the list. Sorting is done with the custom
    `org-roam-node-sort-by-atime' function. Then, check if a buffer
    exists with the name *TAG-nodes* and if it doesn't create it.

    In that new buffer, switch to org-mode and for every item in the
    sorted-nodes list, go to `point-max', insert a new line, insert
    the string #+transclude: make an org-mode id link with the node's
    id and insert another newline. Once done, run
    `org-transclusion-add-all' to activate the transclusion links and
    view editable versions of the selected nodes.

    Finally, restore the buffer from which this function was called
    and insert and org-mode elisp link that runs `switch-to-buffer'
    to switch to the newly-created buffer."
      (interactive "MTag: ")
      (let* ((init-list (org-roam-node-list))
	     (tagged-nodes (cl-remove-if-not (lambda (NODE)
					       (member TAG (org-roam-node-tags NODE)))
					     init-list))
	     (sorted-nodes (reverse (sort tagged-nodes #'org-roam-node-sort-by-atime)))
	     (buffer-name (concat "*" TAG "-nodes*"))
	     (buffer (get-buffer-create buffer-name)))
	(save-excursion
	  (with-current-buffer buffer
	    (org-mode)
	    (dolist (node sorted-nodes)
	      (goto-char (point-max))
	      (newline)
	      (insert
	       "#+transclude: "
	       (org-link-make-string
		(concat "id:" (org-roam-node-id node))))
	       (newline))
	    (org-transclusion-add-all)))
	(insert
	 (org-link-make-string
	  (concat "elisp:(switch-to-buffer \"" buffer-name "\")")
	  (concat "#" TAG)))))

  #+END_SRC

* Fleeting notes
   This is one of the more interesting sections of my workflow as its really custom and from what I have seen really unique. The zettelkasten method has a concept of fleeting notes. They are small notes which should be easy and non intrusive to write quickly to capture ideas and need to be archived when done. I "abuse" the todo-keywords org provides for this to completely repurpose them into what I need. As mentioned above, my org-roam-node-find UI shows the todo state of files which have one. 

Now which files have a todo state? Since org-roam-v2, headings can have IDs and can become nodes. Headings can also have a todo state. The todo states I use are helpful for me for a lot purposes. Inbox, Processing, To-Read and Wait show in which level of editing something is while Urgent is there for things I need to get to ASAP and Low-Priority is for things I want to remember but I can do them whenever. This gives me a lot of flexibility in my daily (fleeting) notes as I can define all of these and then search my zettelkasten for things with this keyword. But, headings have neither an ID nor a todo state in their creation. So I created a function which gives these to a new heading. Together with these, it links the fleeting note to a file named Current Projects, which acts as an index for my fleeting notes so they are not fully disconnected from the system and I have another way of viewing all of them together. To add the link without a prompt (such as that of org-roam-node-insert) I use a skeleton which adds an ID link to that file. 

Lastly, for this system to work properly for fleeting notes I need a seamless way of archiving my daily notes once I am done with the idea they store. For that, we need to define a function which deleted the ID of a node. But running that manually is by no means seamless and in my opinion unacceptable. An idea I found which works perfectly for this is the last code snippet in this section. Essentially, it adds to the org-after-todo-state-change-hook a check of what the new keyword is. If it is DONE, it runs org-id-delete-entry, deleting the ID. Therefore, whenever I set the item's state to done, it removes its ID archiving it from the system. But the file is never deleted, so if I want the context again, I can look for it in the daily directory. But, if I were to do this with the org-roam-dailies package I would reach a big problem. As the file itself gets an ID but not a todo state, it would have an ID which isn't removable automatically, something which would as mentioned above break the system in my opinion. So, these files are created with org-journal so that I can give IDs only to the headings. There isn't much configuration on that end, just some different formatting to a format I think makes more sense. 
   
#+BEGIN_SRC elisp :tangle yes

  (setq org-todo-keywords
	'((sequence "INBOX(i)"
		    "PROCESSING(p)"
		    "URGENT(u)"
		    "LOW-PRIORITY(l)"
		    "WAIT(w)"
		    "TO-READ(r)"
		    "|"
		    "DONE(d)"
		    )))

  (setq org-agenda-files
	'("~/org_roam"
	  "~/org_roam/daily"
	  "~/org_roam/ref"))

  (setq org-journal-dir "~/org_roam/daily"
	org-journal-file-format "%d-%m-%Y.org"
	org-journal-time-format "%a, %d/%m-%R")

  (add-hook 'org-agenda-mode-hook 'visual-line-mode)

  (define-skeleton project-skeleton
    "This skeleton inserts a link to the Current Projects file in the org-roam directory. 

  Its used in my fleeting note initialization function as a means
  to always make new fleeting notes point to the current projects
  file, as that is that files purpose"
    ""
    "- tags :: [[id:b5e71fe5-9d76-4f7f-b58d-df6a561e6a6b][Current Projects]]")

  (defun org-roam-init-fleeting-note ()
    "Prescribe an ID to the heading making it a node in org-roam, then
    add it the inbox by giving it a todo keyword. Finally, insert a new
    line and the `project-skeleton', linking the new file to the Current
    Projects file.

   This helps automate the process of creating new fleeting notes
   in combination with the `org-journal' commands"
    (interactive)
    (org-id-get-create)
    (evil-open-below 1)
    (project-skeleton)
    (org-todo))

  (defun org-id-delete-entry ()
  "Remove/delete an ID entry. Saves the current point and only does this if inside an org-heading."
  (interactive)
    (save-excursion
      (org-back-to-heading t)
      (when (org-entry-delete (point) "ID"))))

  (add-to-list 'org-after-todo-state-change-hook
	       (lambda ()
		 (when (equal org-state "DONE")
		   (org-id-delete-entry))))

  (defun org-roam-node-find-todos ()
    "Filtered view of org-roam-node-find which displays only nodes
  with a todo state. All my fleeting notes typically have a todo
  state indicating I need to work on them so this filter helps me
  out"
    (interactive)
    (org-roam-node-find nil nil #'org-roam-node-todo))

#+END_SRC


* Capture Templates
   Capture templates are really the "heart" of my zettelkasten workflow. By having a prefefined form for all files I create with the system I do not lose time trying to get a standard format on them. Its very important therefore to have at least a well customised default template. The rest of my templates here are for the capturing of specific things. Mine isn't that special but it has some important things.

   The outline capture template is part of the workflow I have crafted with the functions of the zetteldesk (see below). Essentially they are used for outlining a subject during revision and are files that are densely linked with everything that has to do with the subject. After done, they are archived (meaning I remove their ID) as they annoy me in org-roam-node-find and org-roam-ui. I have a shortcut to jump to the directory in which they are located so I do not really fear losing them. One might ask why make them through org roam in the first place if I am going to remove their ID. Well the answer is simple. Its easier this way. While working on it, I want it to be a node so I can find it faster with org-roam commands. But when done, its not actually useful info to keep, so I archive it, but its stored in its own directory so I can find it if I need it again. 

   Then the other 2 templates I define are used for bibliographic information. Basic part of these is that they are stored in a subdirectory of the org_roam folder named ref and have tags depending on what type of file they are. For example, all articles I have have a tag article, and books have a tag book. The bibliography reference template is for things stored in my .bib file. This is mostly things like scientific articles. This is a very neat template as it uses a lot of the information the bibliography file has to make the template really functional. My favourite part of it is that if the entry has a pdf file attached to it, it will automatically set up org-noter to work with that file. The other template I use (info reference) is for creating reference notes from emacs info buffers. org-roam-capture-templates holds some special values if it is invoked in some special buffers one of which is the info-buffer. Specifically, it stores that the capture process was started in an info buffer, which file the buffer was visiting and which node it was in. With this info (no pun intended) and some elisp magic, you can automatically create a link that points to the info buffer the capture was invoked from so you have a reference point when you look at the note again. I found this a very cool feature of org-roam-capture-templates so I integrated it in a template. 

   Also part of my templates I use for bibliographic information, is the org-roam-capture-ref-templates variable. This one is invoked when one captures a web page using org-roam-protocol. Besides books, articles, info pages and whatever else the above 2 cover, capturing info from a web page, is very important to my workflow. So I need to have a good template for it. Its not much, but its important. Org-roam-protocol doesn't store much special info besides the title of the web page so this template is about as simple as my default one. 

   Lastly, I define the org-roam-dailies-capture-templates. As discussed above I do not use these too much, but since I have tried them I have kept the template I made for them. Its got the same formatting as the org-journal ones so if a file is created with one method the other can add things to it.

   #+BEGIN_SRC elisp :tangle yes

     (setq org-roam-capture-templates
	   '(("d" "default" plain "%?" :if-new
	      (file+head "${slug}-%<%d-%m-%y>.org" "#+title: ${title}
     - index ::  
     - tags :: ")
	      :unarrowed t
	      :jump-to-captured t)

	     ("o" "outline" plain "%?" :if-new
	      (file+head "outlines/${slug}-%<%d-%m-%y>.org" "#+title: ${title}\n
     ,#+filetags: outline")
	      :unarrowed t
	      :jump-to-captured t)

	     ("r" "bibliography reference" plain
	      "%?"
	      :if-new
	      (file+head "ref/${citekey}.org" "#+title: ${title}\n
     ,#+filetags: ${entry-type}
     - keywords :: ${keywords}
     - tags :: 

     ,* Analysis of ${entry-type} by ${author}
     :PROPERTIES:
     :URL: ${url}
     :NOTER_DOCUMENT: ${file}  
     :NOTER_PAGE:              
     :END:")
	      :unnarrowed t
	      :jump-to-captured t)

	     ("i" "info reference" plain
	      "%?"
	      :if-new
	      (file+head "ref/${slug}.org" "#+title: ${title}\n
     ,#+filetags: %:type
     - tags :: \n

     [[elisp:(Info-goto-node \"(%:file)%:node\")][Link to Info page]]
     \n
     ")
	      :unnarowed t)

	     ("e" "elfeed" plain
	      "%?"
	      :if-new
	      (file+head "ref/${slug}.org" "#+title: %:description\n
     ,#+filetags: %:type
     - keywords ::
     - tags :: \n\n\n

     [[%:link][Link to Elfeed Buffer]]
     [[%:elfeed-entry-link][Link to Web Page]]")
	      :unnarowed t)))

     (setq org-roam-capture-ref-templates 
	   '(("r" "ref" entry "* %?" :target
	      (file+head "ref/${slug}.org" "#+title: ${title}\n
     ,#+filetags: 
      - tags :: \n")
	      :unnarrowed t
	      :jump-to-captured t)))

     (setq org-roam-dailies-capture-templates
	   '(("d" "default" entry "* %?" :if-new
	      (file+head "%<%Y-%m-%d>.org" "#+title: %<%Y-%m-%d>\n#+filetags: daily")
	      :empty-lines 1)))

   #+END_SRC

   #+RESULTS:
   | d | default | entry | * %? | :if-new | (file+head %<%Y-%m-%d>.org #+title: %<%Y-%m-%d> |

* Providing the packages to be loaded in init.el
  #+BEGIN_SRC elisp :tangle yes

    (provide 'zettelkasten)

  #+END_SRC
  
