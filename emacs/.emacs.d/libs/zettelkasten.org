#+TITLE: Org-Roam, References and the Zettelkasten Workflow

This file is a core part of my emacs configuration and is all about my Org-roam setup and my reference management inside org. Its based on the Zettelkasten method and the Roam Research website. Notes are linked with one another. Bibtex completion (and the existence of .bib files in general) as well as Org-ref help manage bibliographic references inside org. I also use Zotero as it easily allows me to gather my bibliographies. It exports a .bib file which these two use. Org Roam Bibtex (ORB) is a package that combines all of these to help you add citation links from org-ref inside an org-roam buffer. This section includes all the customisations and settings of these packages. This is a very large section of my config (hence why it has its own file) as I have really customised this workflow a lot. 

* Org-Roam general setup
  This part is the general setup of org-roam. It contains the setup, removing the warning message for the migration to v2, and the use-package declaration for org-roam. There I put the org roam directory, the various defmethods I use, my display template and a resize to the org-roam buffer as taking half the screen isn't something I like. I much prefer it to be a bit smaller than the main window.

  A lot of the defmethods defined here are for my display template as I think its useful to see directories, backlink count and todo state of nodes in the org-roam-node-find UI. Then there is the oddball org-roam-node-backlinkscount-number which is identical almosy to org-roam-node-backlinkscount, but its different output is useful for a function I define later and the org-roam-node-buffer defmethod which is a very helpful defmethod that imo should have been defined in org-roam. It returns the buffer associated to a node, and nil if there is none. I use this in various parts of my config and I consider it an important defmethod. 
   
 #+BEGIN_SRC elisp :tangle yes

   (add-hook 'after-init-hook 'org-roam-setup)
   (setq org-roam-v2-ack t)

   (use-package org-roam
     :config
     (setq org-roam-directory "~/org_roam"
	   org-roam-dailies-directory "~/org_roam/daily")

     (cl-defmethod org-roam-node-directories ((node org-roam-node))
       "Access slot \"directory\" of org-roam-node struct CL-X"
       (if-let ((dirs (file-name-directory (file-relative-name (org-roam-node-file node) org-roam-directory))))
	   (format "(%s)" (car (f-split dirs)))
	 ""))

     (cl-defmethod org-roam-node-backlinkscount ((node org-roam-node))
       "Access slot \"backlinks\" of org-roam-node struct CL-X"
       (let* ((count (caar (org-roam-db-query
			    [:select (funcall count source)
				     :from links
				     :where (= dest $s1)
				     :and (= type "id")]
			    (org-roam-node-id node)))))
	 (format "[%d]" count)))

     (cl-defmethod org-roam-node-backlinkscount-number ((node org-roam-node))
       "Access slot \"backlinks\" of org-roam-node struct CL-X. This
       is identical to `org-roam-node-backlinkscount' with the
       difference that it returns a number instead of a fromatted
       string. This is to be used in
       `org-roam-node-sort-by-backlinks'"
       (let* ((count (caar (org-roam-db-query
			    [:select (funcall count source)
				     :from links
				     :where (= dest $s1)
				     :and (= type "id")]
			    (org-roam-node-id node)))))
	 count))

     (cl-defmethod org-roam-node-todostate ((node org-roam-node))
       "Modified version of org-roam-node-todo to look a bit better"
       (if-let ((state (org-roam-node-todo node)))
	   (format "Status: %s" state)))

     (cl-defmethod org-roam-node-buffer ((node org-roam-node))
       "Access slot \"buffer\" of org-roam-node struct CL-X"
       (let ((buffer (get-file-buffer (org-roam-node-file node))))
	 buffer))

     (setq org-roam-node-display-template "${title:100} ${backlinkscount:6} ${todostate:20} ${directories:8} ${tags:25}")

     (add-to-list 'display-buffer-alist
		  '("\\*org-roam\\*"
		    (display-buffer-in-direction)
		    (direction . right)
		    (window-width . 0.40)
		    (window-height . fit-window-to-buffer))))

   #+END_SRC

* Useful Functions
   Org roam is a cornerstone of my workflow (which is the reason this file is so stupidly large). I have written various "helper" functions for my own assistance that are meant to be used with org-roam. This section includes those functions. They are all documented well so I do not think I need to describe them. 

#+BEGIN_SRC elisp :tangle yes

  (defun org-roam-buffer-without-latex ()
      "Essentially `org-roam-buffer-toggle' but it ensures latex previews are turned off before toggling the buffer.

    This is useful because especially with index files, having
    latex previews on, makes opening the buffer very slow as it
    needs to load previews of many files. If you by default have
    `org-startup-with-latex-preview' set to t, you have probably
    noticed this issue before. This function solves it."
      (interactive)
      (let ((org-startup-with-latex-preview nil))
	(org-roam-buffer-toggle)))

  (defun org-roam-permanent-note-p (NODE)
    "Check if NODE is at the top level org_roam directory using the
    `org-roam-node-directories' function. If it isn't,
    `org-roam-node-directories' will return a non empty string,
    therefore this expression will evaluate to nil. The way my
    notes are sorted, when a note is placed on the top level its a
    permanent note, while fleeting and reference notes are placed
    in subdirectories.

  Therefore, this predicate function allows me to create a version
  of `org-roam-node-find' which only shows my permanent notes,
  which can be useful in some cases. That filtered function is
  `org-roam-find-permanent-node'."
    (string-equal (org-roam-node-directories NODE) ""))

  (defun org-roam-node-poi-p (NODE)
    "Check if NODE has the tag POI. Return t if it does"
    (string-equal (car (org-roam-node-tags NODE)) "POI"))

  (defun org-roam-find-permanent-node ()
    "Execute `org-roam-node-find' with the list being filtered to
  only include permanent notes. In my system that is synonymous to
  saying include only notes at the top level directory. The
  filtering is done with the `org-roam-permanent-note-p' predicate
  function."
    (interactive)
    (org-roam-node-find nil nil #'org-roam-permanent-note-p))
#+END_SRC

* Acting on backlinks
  Backlinks are a pivotal part of this workflow. A file has a backlink if another file links to it. As a core part of my workflow revolves around index files (or Maps of Contents) and those are files that basically everything connected to that subject links to them, they end up being files with a lot of backlinks. I have some functions here that act on backlinks which I consider useful. Excluded from this list are two defmethods I use concerning backlinks as I define all my defmethods in the first part of the config.

  The first is org-roam-node-backlinkscount, a function I initially found on the OR wiki on github, which finds the number of backlinks a note has and formats them in a nice string. Its meant to be used with org-roam-node-display-template to show the number of backlinks in the org-roam-node-UI. The second is an almost identical function, but instead of returning a formatted string it returns a number. That is meant to be used with org-roam-node-sort-by-backlinks, a function defined below which sorts nodes by the number of backlinks they have. Number comparison is much easier than comparison of string representing numbers, and due to the extra formatting applied (which I like for the purpose that function has) I couldn't find how to convert that string to a number so I just made a rewrite with that small change.  

  #+BEGIN_SRC elisp :tangle yes

    (defvar-local org-roam-backlinks nil
      "Buffer local variable displaying a list of the absolute paths
      of all the files that are backlinked to current node. These are
      not added by default, and as such this variable has the value
      nil but they can be added by running the
      `org-roam-backlink-files' function on a node.")

    (defvar-local org-roam-backlink-pdfs nil
      "After running `org-roam-export-backlinks-to-latex-pdf', to
      export a node and all its backlinks to pdf, the value of this
      variable in the original node's buffer will become a list of
      all the pdfs that were created. This is to ease the process of
      combining them as the value of this variable can then be passed
      to a program such as pdftk to combine them.")

    (defun org-roam-node-sort-by-backlinks (completion-a completion-b)
      "Sorting function for org-roam that sorts the list of nodes by
    the number of backlinks. This is the sorting function in
    `org-roam-node-find-by-backlinks'"
      (let ((node-a (cdr completion-a))
	    (node-b (cdr completion-b)))
	(>= (org-roam-node-backlinkscount-number node-a)
	    (org-roam-node-backlinkscount-number node-b))))

    (defun org-roam-node-find-by-backlinks ()
      "Essentially works like `org-roam-node-find' (although it uses
    a combination of `find-file' and `org-roam-node-read' to
    accomplish that and not `org-roam-node-find' as only
    `org-roam-node-read' can take a sorting function as an argument)
    but the list of nodes is sorted by the number of backlinks
    instead of most recent nodes. Sorting is done with
    `org-roam-node-sort-by-backlinks'"
      (interactive)
      (find-file (org-roam-node-file (org-roam-node-read nil nil #'org-roam-node-sort-by-backlinks))))

    (defun org-roam-backlink-query ()
      "Simple org-roam query function that stores the IDs of all the
      files that link to the node at point. This is a modified part
      of the `org-roam-backlinks-get' function keeping only the part
      necessary for `org-roam-backlink-files' to work as this is a
      complimentary function to that"
      (org-roam-db-query
       [:select [source dest]
		:from links
		:where (= dest $s1)
		:and (= type "id")]
       (org-roam-node-id (org-roam-node-at-point))))

    (defun org-roam-backlink-files ()
	"Get all nodes that link to the node at point with the
	`org-roam-backlink-query' function, find their absolute path
	and save a list of those paths to the buffer local variable
	`org-roam-backlinks'.

      With the list, you can act on all those files together. This is
      exceptionally useful with index files as it allows you to do an
      action on all files linked to this index automatically."
	(interactive)
	(let ((backlinks (length (org-roam-backlink-query)))
	      (org-roam-backlinks))
	  (dotimes (number backlinks)
	    (let* ((id (car (nth number (org-roam-backlink-query))))
		   (node (org-roam-node-from-id id)))
	      (setq-local org-roam-backlinks (cons (org-roam-node-file node) org-roam-backlinks))))
	  (message "%s" org-roam-backlinks)))

    (defun org-roam-export-backlinks-to-latex-pdf ()
      "Export the current buffer and every buffer that mentions it to
    a pdf through latex and pandoc. Makes use of the
    `org-roam-backlink-files' function to find all the
    backlinks. Also saves all the pdf names in a variable called
    `org-roam-backlink-pdfs'. These names can then be passed to
    something like pdftk to merge them into one pdf"
      (interactive)
      (org-roam-backlink-files)
      (setq org-roam-backlink-pdfs nil)
      (save-current-buffer
	(let ((backlinks (cons (buffer-file-name) org-roam-backlinks))
	      (org-startup-with-latex-preview nil))
	  (while backlinks
	    (find-file (car backlinks))
	    (org-pandoc-export-to-latex-pdf)
	    (setq org-roam-backlink-pdfs
		  (cons (concat (file-name-sans-extension (car backlinks)) ".pdf") org-roam-backlink-pdfs))
	    (setq backlinks (cdr backlinks)))
	  ))
      (message "%s" "Done!"))

  #+END_SRC
  
* Bibtex completion (Ivy) and Org-Ref
  Ivy Bibtex and Org ref are two excellent packages for managing bibliography. The main thing I need to configure is the location of my master .bib file and pdfs (which are exported with Zotero). I also change some other variables where I see fit.
   
  In detail
  - Zotero exports a .bib file with all my references (the main way it "talks" to Emacs). I "tell" ivy-bibtex and org-ref the location of this file for usage in their various commands.
  - I allow ivy-bibtex to query by keywords or abstract. Can be useful
  - I make the default action of ivy-bibtex, the edit notes action. Personally, its the action I use most as opening the link/pdf to the reference (which is the original default) is more easily done from Zotero imo. In Emacs I find more utility in this function creating bibliographical notes.
  - Since opening the pdf, url or DOI of a bibtex entry is no longer the default action in my config, I bind it to the letter p in the options menu of Ivy-bibtex
  - Change the citation format bibtex uses on org mode. I enter cite links with org-ref-insert-cite-links so I make the ivy-bibtex link be a link to the pdf.

     #+BEGIN_SRC elisp :tangle yes
       (setq bibtex-completion-bibliography
	     '("~/Sync/My_Library.bib")
	     bibtex-completion-pdf-field "File"
	     bibtex-completion-library-path '("~/Sync/Zotero_pdfs"))
	
       (setq bibtex-completion-additional-search-fields '(keywords abstract))
	
       (setq ivy-bibtex-default-action 'ivy-bibtex-edit-notes)
       (ivy-add-actions
	'ivy-bibtex
	'(("p" ivy-bibtex-open-any "Open pdf, url or DOI")))
	
       (setq bibtex-completion-format-citation-functions
	     '((org-mode . bibtex-completion-format-citation-org-title-link-to-PDF)
	       (latex-mode . bibtex-completion-format-citation-cite)
	       (markdown-mode . bibtex-completion-format-citation-pandoc-citeproc)
	       (python-mode . bibtex-completion-format-citation-sphinxcontrib-bibtex)
	       (rst-mode . bibtex-completion-format-citation-sphinxcontrib-bibtex)
	       (default . bibtex-completion-format-citation-default)))
    #+END_SRC

* Org Roam Bibtex, Protocols (Reference notes) and UI (graphing capabilities)
   I require a bunch of packages so ORB, org roam ui and the roam protocols work as intended. I also make orb use ivy for completions.

   For a brief description of each ones use case, org-roam-bibtex (aka ORB) is an excellent package for bibliography management inside org-roam. Since other packages help out with this, the big thing this one does is that it hooks bibtex-completion to use the org-roam ecosystem for its notes. Org-protocol is for capturing info from a web page and adding it to an org file. The org-roam-protocol is basically integrating that to the org-roam ecosystem. Org-roam-ui is the new graphing package designed for org-roam-v2. We used to use org-roam-server for this, but with the migration to v2, this package was created (which is honestly better than org-roam-server) for an excellent visual graph of your org roam directory. There are many advantages to viewing your knowledge repository with a graph so this is a must have package. 

#+BEGIN_SRC elisp :tangle yes
  
  (require 'org-roam-bibtex)
  (org-roam-bibtex-mode 1)
  
  (setq orb-insert-interface 'ivy-bibtex
	orb-note-actions-interface 'ivy)
  (setq orb-preformat-keywords '("citekey" "author" "date" "entry-type" "keywords" "url" "file"))
  
  (require 'org-protocol)
  (require 'org-roam-protocol)
  
  (require 'websocket)
  (require 'org-roam-ui)
  
#+END_SRC


* Fleeting notes
   This is one of the more interesting sections of my workflow as its really custom and from what I have seen really unique. The zettelkasten method has a concept of fleeting notes. They are small notes which should be easy and non intrusive to write quickly to capture ideas and need to be archived when done. I "abuse" the todo-keywords org provides for this to completely repurpose them into what I need. As mentioned above, my org-roam-node-find UI shows the todo state of files which have one. 

Now which files have a todo state? Since org-roam-v2, headings can have IDs and can become nodes. Headings can also have a todo state. The todo states I use are helpful for me for a lot purposes. Inbox, Processing, To-Read and Wait show in which level of editing something is while Urgent is there for things I need to get to ASAP and Low-Priority is for things I want to remember but I can do them whenever. This gives me a lot of flexibility in my daily (fleeting) notes as I can define all of these and then search my zettelkasten for things with this keyword. But, headings have neither an ID nor a todo state in their creation. So I created a function which gives these to a new heading. Together with these, it links the fleeting note to a file named Current Projects, which acts as an index for my fleeting notes so they are not fully disconnected from the system and I have another way of viewing all of them together. To add the link without a prompt (such as that of org-roam-node-insert) I use a skeleton which adds an ID link to that file. 

Lastly, for this system to work properly for fleeting notes I need a seamless way of archiving my daily notes once I am done with the idea they store. For that, we need to define a function which deleted the ID of a node. But running that manually is by no means seamless and in my opinion unacceptable. An idea I found which works perfectly for this is the last code snippet in this section. Essentially, it adds to the org-after-todo-state-change-hook a check of what the new keyword is. If it is DONE, it runs org-id-delete-entry, deleting the ID. Therefore, whenever I set the item's state to done, it removes its ID archiving it from the system. But the file is never deleted, so if I want the context again, I can look for it in the daily directory. But, if I were to do this with the org-roam-dailies package I would reach a big problem. As the file itself gets an ID but not a todo state, it would have an ID which isn't removable automatically, something which would as mentioned above break the system in my opinion. So, these files are created with org-journal so that I can give IDs only to the headings. There isn't much configuration on that end, just some different formatting to a format I think makes more sense. 
   
#+BEGIN_SRC elisp :tangle yes

  (setq org-todo-keywords
	'((sequence "INBOX(i)"
		    "PROCESSING(p)"
		    "URGENT(u)"
		    "LOW-PRIORITY(l)"
		    "WAIT(w)"
		    "TO-READ(r)"
		    "|"
		    "DONE(d)"
		    )))

  (setq org-agenda-files
	'("~/org_roam"
	  "~/org_roam/daily"
	  "~/org_roam/ref"))

  (setq org-journal-dir "~/org_roam/daily"
	org-journal-file-format "%d-%m-%Y.org"
	org-journal-time-format "%a, %m/%d-%R")

  (add-hook 'org-agenda-mode-hook 'visual-line-mode)

  (define-skeleton project-skeleton
    "This skeleton inserts a link to the Current Projects file in the org-roam directory. 

  Its used in my fleeting note initialization function as a means
  to always make new fleeting notes point to the current projects
  file, as that is that files purpose"
    ""
    "- tags :: [[id:b5e71fe5-9d76-4f7f-b58d-df6a561e6a6b][Current Projects]]")

  (defun org-roam-init-fleeting-note ()
    "Prescribe an ID to the heading making it a node in org-roam, then
    add it the inbox by giving it a todo keyword. Finally, insert a new
    line and the `project-skeleton', linking the new file to the Current
    Projects file.

   This helps automate the process of creating new fleeting notes
   in combination with the `org-journal' commands"
    (interactive)
    (org-id-get-create)
    (evil-open-below 1)
    (project-skeleton)
    (org-todo))

  (defun org-id-delete-entry ()
  "Remove/delete an ID entry. Saves the current point and only does this if inside an org-heading."
  (interactive)
    (save-excursion
      (org-back-to-heading t)
      (when (org-entry-delete (point) "ID"))))

  (add-to-list 'org-after-todo-state-change-hook
	       (lambda ()
		 (when (equal org-state "DONE")
		   (org-id-delete-entry))))

  (defun org-roam-node-find-todos ()
    "Filtered view of org-roam-node-find which displays only nodes
  with a todo state. All my fleeting notes typically have a todo
  state indicating I need to work on them so this filter helps me
  out"
    (interactive)
    (org-roam-node-find nil nil #'org-roam-node-todo))

#+END_SRC


* Capture Templates
   Capture templates are really the "heart" of my zettelkasten workflow. By having a prefefined form for all files I create with the system I do not lose time trying to get a standard format on them. Its very important therefore to have at least a well customised default template. The rest of my templates here are for the capturing of specific things. Mine isn't that special but it has some important things.  

The project template is a rather new one to my workflow. The zettelkasten workflow defines a type of notes called project notes which you are meant to use to plan out your project inside the zettelkasten. Because of all the ideas there, you never have to start from a blank box but you can take ideas from anywhere and add them to a project file. This part of my workflow isn't polished yet, but I am thinking of using a project file for each project and then headings which I can make nodes for each part of the project I want to document. Each heading can be archived easily with the same method as the daily files. For the central project file, I could archive them by removing their ID manually or something better if I figure it out. 

Anoter idea for this which is more zettelkasten-y (yes that is a word now, deal with it) is to have a file for each section of the project and link all of them (either to an index or through the use of filetags) together. The problem is that then archiving becomes harder unless I figure out a good, easy and frictionless way of archiving files by removing their ID. This part is heavily WIP though as I said already

Then the other 2 templates I define are used for bibliographic information. Basic part of these is that they are stored in a subdirectory of the org_roam folder named ref and have tags depending on what type of file they are. For example, all articles I have have a tag article, and books have a tag book. The bibliography reference template is for things stored in my .bib file. This is mostly things like scientific articles. This is a very neat template as it uses a lot of the information the bibliography file has to make the template really functional. My favourite part of it is that if the entry has a pdf file attached to it, it will automatically set up org-noter to work with that file. The other template I use (info reference) is for creating reference notes from emacs info buffers. org-roam-capture-templates holds some special values if it is invoked in some special buffers one of which is the info-buffer. Specifically, it stores that the capture process was started in an info buffer, which file the buffer was visiting and which node it was in. With this info (no pun intended) and some elisp magic, you can automatically create a link that points to the info buffer the capture was invoked from so you have a reference point when you look at the note again. I found this a very cool feature of org-roam-capture-templates so I integrated it in a template. 

Also part of my templates I use for bibliographic information, is the org-roam-capture-ref-templates variable. This one is invoked when one captures a web page using org-roam-protocol. Besides books, articles, info pages and whatever else the above 2 cover, capturing info from a web page, is very important to my workflow. So I need to have a good template for it. Its not much, but its important. Org-roam-protocol doesn't store much special info besides the title of the web page so this template is about as simple as my default one. 

Lastly, I define the org-roam-dailies-capture-templates. As discussed above I do not use these too much, but since I have tried them I have kept the template I made for them. Its got the same formatting as the org-journal ones so if a file is created with one method the other can add things to it.

   #+BEGIN_SRC elisp :tangle yes
     
     (setq org-roam-capture-templates
	   '(("d" "default" plain "%?" :if-new
	      (file+head "${slug}-%<%d-%m-%y>.org" "#+title: ${title}\n
     - index ::  
     - tags ::  ")
	      :unarrowed t
	      :jump-to-captured t)
     
	     ("p" "project" plain "%?" :if-new
	      (file+head "project/${slug}-%<%d-%m-%y>.org" "#+title: ${title}\n
     - index ::  
     - tags ::  
     ,#+filetags: ")
	      :unarrowed t
	      :jump-to-captured t)
     
	     ("r" "bibliography reference" plain
	      "%?"
	      :if-new
	      (file+head "ref/${citekey}.org" "#+title: ${title}\n
     ,#+filetags: ${entry-type}
     - keywords :: ${keywords}
     - tags :: 
     
     ,* Analysis of ${entry-type} by ${author}
     :PROPERTIES:
     :URL: ${url}
     :NOTER_DOCUMENT: ${file}  
     :NOTER_PAGE:              
     :END:")
	      :unnarrowed t
	      :jump-to-captured t)
     
	     ("i" "info reference" plain
	      "%?"
	      :if-new
	      (file+head "ref/${slug}.org" "#+title: ${title}\n
     ,#+filetags: %:type
     - tags :: 
     
     [[elisp:(Info-goto-node \"(%:file)%:node\")][Link to Info page]]
     \n
     ")
	      :unnarowed t)))
     
     (setq org-roam-capture-ref-templates 
	   '(("r" "ref" entry "* %?" :target
	      (file+head "ref/${slug}.org" "#+title: ${title}\n
     ,#+filetags: 
      - tags :: ")
	      :unnarrowed t
	      :jump-to-captured t)))
     
     (setq org-roam-dailies-capture-templates
	   '(("d" "default" entry "* %?" :if-new
	      (file+head "%<%Y-%m-%d>.org" "#+title: %<%Y-%m-%d>\n#+filetags: daily")
	      :empty-lines 1)))
     
   #+END_SRC


* Implementing the Zettelkasten "desktop" to org-roam 
  A desktop, is the top surface of a desk, or in the digital world an area in a computer screen in which some people arrange their icons, similarly to how they would arrange stuff in their desk. Now if I had an irl zettelkasten, I know for sure that my desktop would be filled with little notes with various topic when studying something. So why shouldn't I have a digital desktop where I can spread all my notes and look at them one by one, when studying. Wouldn't that be handy?

  This very thought is what started this idea. The idea of the zettelkasten-desktop, which I shortened to zetteldesk as I wanted my functions to not have huge names. The plan for the finished project is a dedicated buffer in which I can input whichever note I want and view them all at the same time, a way to create a true desktop experience inside emacs. Once done, it will be a great benefit to my workflow I believe.

  So far, I have done only what I would consider to be the first part of the workflow. I have created a system which marks an org-roam-node (from a completion menu) and adds it to the zetteldesk and a filtered org-roam-node-find which shows me only those nodes. Furthermore, the node doesn't have to be open currently, the functions take care of opening nodes. As I liked the idea, I thought it should be something I can do with any buffer. A lot of the times when studying, or doing any sort of research, you need not only your notes and a place to combine your ideas, but also supplementary materials to that work. That might be a pdf, a directory structure, an info page or whatever else suits your boat. So all the functionality written has a version for nodes and one generally for buffers.

  I plan for this to become its own emacs package for people to use. Now some of its functionality is and will be really specific to my workflow, but hopefully others may like it and use it. For this reason this section tangles to a different file zetteldesk.el. 

** Dependencies
   As I want this to work independently to my config, this section has a copy of all the custom function I use which were not defined in this section as I felt they fit more somewhere else in my config. These are the dependencies this has from my config. For general dependencies I will do those once this is actually complete enough to make its own package

   #+BEGIN_SRC elisp :tangle zetteldesk.el

     (cl-defmethod org-roam-node-buffer ((node org-roam-node))
       "Access slot \"buffer\" of org-roam-node struct CL-X"
       (let ((buffer (get-file-buffer (org-roam-node-file node))))
	 buffer))

     (defun org-roam-node-poi-p (NODE)
       "Check if NODE has the tag POI. Return t if it does"
       (string-equal (car (org-roam-node-tags NODE)) "POI"))

     (defun org-roam-backlink-query ()
       "Simple org-roam query function that stores the IDs of all the files that link
       to the node at point. This is a modified part of the
       `org-roam-backlinks-get' function keeping only the part necessary for
       `org-roam-backlink-files' to work as this is a complimentary function to
       that"
       (org-roam-db-query
	[:select [source dest]
		 :from links
		 :where (= dest $s1)
		 :and (= type "id")]
	(org-roam-node-id (org-roam-node-at-point))))

   #+END_SRC
   
** Predicate Functions
I tried to follow a rather simple idea to do this and not overcomplicate things. Essentially, I define a buffer-local variable and give it a default value. Then I define the predicate function that shows when a buffer is part of the zettelkasten desktop. A buffer will be part of the desktop only if the value of that variable in the buffer is not equal to the default. I define the low level predicate functions that check if a buffer or node is part of the zetteldesk and then I define a predicate that checks if a buffer is part of the zetteldesk but not an org-roam file, as on the switch-to-buffer prompt I do not care about org-roam files (I can view them with org-roam-node-file) and another predicate which filters the list down further to only include org files that are part of the zetteldesk but not org-roam files (which is handy for another function below).

#+BEGIN_SRC elisp :tangle zetteldesk.el

  (defvar-local zetteldesk "default"
    "Buffer local variable that determines whether a buffer is part
    of the current zetteldesk. A buffer is part of the zetteldesk
    only if the value of this variable is not its default value in
    that buffer. Its default value is default because I am not
    creative.")

  (defun zetteldesk-p (BUFFER)
    "Check if BUFFER is part of the current `zetteldesk'"
    (not (eq (default-value 'zetteldesk) (buffer-local-value 'zetteldesk (cdr BUFFER)))))

  (defun zetteldesk-buffer-p (BUFFER)
    "Check if BUFFER is similtaneously part of the current
    `zetteldesk' and not a buffer for an org-roam file.

  Org-roam file buffers are better viewed with `org-roam-node-file'
  so this function filters down the database to non org-roam
  zetteldesk buffers. This is what is used to create the filter
  function `zetteldesk-switch-to-buffer'"
    (and (zetteldesk-p BUFFER) (not (org-roam-buffer-p (cdr BUFFER)))))

  (defun zetteldesk-node-p (NODE)
    "Check if NODE is associated with an open buffer. If it is,
    check if that buffer is part of the current `zetteldesk'. If it
    isn't, return nil.

  This function is used as a filter function to create
  `zetteldesk-node-find' which is a filtered view of
  `org-roam-node-find'"
    (if (org-roam-node-buffer NODE)
	(not (eq (default-value 'zetteldesk) (buffer-local-value 'zetteldesk (org-roam-node-buffer NODE))))
      nil))

  (defun zetteldesk-org-buffer-p (BUFFER)
    "Check if BUFFER is part of the current `zetteldesk' an org
    file but not one that belongs to org-roam.

  This is used as the filter function for
  `zetteldesk-insert-org-file-contents' which prompts for an org
  file, but as `zetteldesk-insert-node-contents' is a superior
  version for org-roam nodes, that function should not prompts for
  those files"
    (and (zetteldesk-buffer-p BUFFER) (eq (buffer-local-value 'major-mode (cdr BUFFER)) 'org-mode)))

  (defun zetteldesk-pdf-p (BUFFER)
    "Check if BUFFER is part of the current `zetteldesk' and also a pdf file."
    (and (zetteldesk-p BUFFER) (eq (buffer-local-value 'major-mode (cdr BUFFER)) 'pdf-view-mode)))
#+END_SRC

#+RESULTS:
: zetteldesk-node-insert

** Adding and Removing things in the Zetteldesk
   I define 3 adding mechanisms and the matching removing ones, as can seen below. The first is adding/removing a buffer, the second is for a node and the third is adding/removing a node and all its backlinks. They are all really handy for various reasons. 
   
  #+BEGIN_SRC elisp :tangle zetteldesk.el

    (defun zetteldesk-add-to-desktop (BUFFER)
      "Add BUFFER to the current `zetteldesk'"
      (interactive "b")
      (with-current-buffer BUFFER
	(setq-local zetteldesk "foo")))

    (defun zetteldesk-add-node-to-desktop ()
      "Add an org-roam-node to the `zetteldesk' and if there isn't a
      buffer associated to it, create it.

    The node is read through `org-roam-node-read'"
      (interactive)
      (let* ((node (org-roam-node-read))
	     (buffer (org-roam-node-buffer node))
	     (file (org-roam-node-file node))
	     (org-startup-with-latex-preview nil))
	(if (not (eq buffer nil))
	    (with-current-buffer buffer
	      (setq-local zetteldesk "foo"))
	  (with-current-buffer (find-file-noselect file)
	    (setq-local zetteldesk "foo")))))

    (defun zetteldesk-add-backlinks-to-desktop ()
      "Add the current buffer and all its backlinks to the `zetteldesk'. 

    This function queries the database for all the nodes that link to
    the current node with the `org-roam-backlink-query' function and
    then recursively checks if there is an open buffer associated
    with them, and if so adds it to the `zetteldesk'"
      (interactive)
      (setq-local zetteldesk "foo")
      (let ((backlinks (length (org-roam-backlink-query)))
	    (org-startup-with-latex-preview nil))
	(dotimes (number backlinks)
	  (let* ((id (car (nth number (org-roam-backlink-query))))
		  (node (org-roam-node-from-id id))
		  (buffer (org-roam-node-buffer node))
		  (file (org-roam-node-file node)))
	    (if (not (eq buffer nil))
		(with-current-buffer buffer
		  (setq-local zetteldesk "foo"))
	      (with-current-buffer (find-file-noselect file)
		(setq-local zetteldesk "foo")))))))

    (defun zetteldesk-remove-from-desktop (BUFFER)
      "Remove BUFFER from the current `zetteldesk'"
      (interactive "b")
      (with-current-buffer BUFFER
	(kill-local-variable 'zetteldesk)))

    (defun zetteldesk-remove-node-from-desktop ()
      "Add an org-roam-node to the `zetteldesk' and if there isn't a
      buffer associated to it, create it.

    The node is read through `org-roam-node-read'"
      (interactive)
      (let* ((node (org-roam-node-read nil #'zetteldesk-node-p))
	     (buffer (org-roam-node-buffer node)))
	(with-current-buffer buffer
	  (kill-local-variable 'zetteldesk))))

    (defun zetteldesk-remove-backlinks-from-desktop ()
      "Remove the current buffer and all its currently open backlinks
      from the `zetteldesk'.

    This function is essentially a carbon copy of
    `zetteldesk-add-backlinks-to-desktop' but instead of adding the
    buffer to the desktop it removes it."
      (interactive)
      (kill-local-variable 'zetteldesk)
      (let ((backlinks (length (org-roam-backlink-query))))
	(dotimes (number backlinks)
	  (let* ((id (car (nth number (org-roam-backlink-query))))
		  (node (org-roam-node-from-id id))
		  (buffer (org-roam-node-buffer node)))
	    (unless (eq buffer nil)
	      (with-current-buffer buffer
		(kill-local-variable 'zetteldesk)))))))

  #+END_SRC 
   
** Filter functions
   Here I define the functions which give you a filtered view of switch-to-buffer and org-roam-node-find to the current zetteldesk. I also define a filtered view of org-roam-node-insert as its not rare to want to insert a link to a file from the zetteldesk

   #+BEGIN_SRC elisp :tangle zetteldesk.el

     (defun zetteldesk-switch-to-buffer ()
       "Execute `switch-to-buffer' with the buffer list being
     filtered (using `zetteldesk-buffer-p') to show only buffers that are
     part of the current `zetteldesk' and not `org-roam-node's."
       (interactive)
       (switch-to-buffer (read-buffer "Zetteldesk Buffers: " nil nil #'zetteldesk-buffer-p)))

     (defun zetteldesk-node-find ()
       "Execute `org-roam-node-find' with the list being
     filtered (using `zetteldesk-node-p') to show only nodes that are
     part of the current `zetteldesk'"
       (interactive)
       (org-roam-node-find nil nil #'zetteldesk-node-p))

     (defun zetteldesk-node-insert ()
       "Execute `org-roam-node-insert' with the list being
     filtered (using `zetteldesk-node-p') to show only nodes that are
     part of the current `zetteldesk'"
       (interactive)
       (org-roam-node-insert #'zetteldesk-node-p))

   #+END_SRC
    
** On the zetteldesk-scratch buffer
   The zetteldesk-scratch buffer is a bit equivalent to the emacs scratch buffer. Its essentially a buffer unique to the session in which you can drop all the links, node contents or whatever else interests you and use it as the place to hold your crude notes until you drop them where they belong. I also envision this to be the buffer in which you drop all the notes you want to view at one time, in the way you would spread them on your desk.

   I am considering making a global minor mode zetteldesk-mode in which map you can put all your keybindings if you do not want the override map littered with those. It will also have a hook when turned on to create the scratch buffer. I will do this as I find it more classy to enable a minor mode than to just run the zetteldesk-create-scratch-buffer at initialization

   Things I have implemented so far
   - Creating a global minor mode for the zetteldesk.
   - Creating a function which initialises the zetteldesk-scratch buffer and hook that to the on-hook of zetteldesk-mode. The primary reason for wanting to define the minor mode was to enable it on startup and have this hook initialise the scratch buffer so I do not have to worry about it. The other reason is that for distributing this as a package I think it makes sense for it to have a minor mode in which I could possibly isolate the keybindings.
   - A function that inserts links to all the POIs in the zetteldesk to the current buffer. The way I have my zettelkasten sorted, my index files have the MOC (map of contents) tag and other important files of a subject have the POI (point of interest) tag. POIs are chosen by opening org-roam UI, blacklisting index files (in my case blacklisting the MOC tag), having a high value for "Node connections size scale" and seeing which nodes stand out the most. This is an idea taken from the book How to make a complete map of every thought you think. I use my zettelkasten for university notes and when revisioning its a great tool to be able to insert links to all POIs in some sort of scratch buffer, then sorting them and with that writing an outline of everything in that lesson. In a way, this does function as an outliner tool.
   - A function that prompts for a node inside the zetteldesk and inserts its contents to the zetteldesk-scratch buffer omitting the properties section where the id is stored. As it uses an absolute number for this, it doesn't exactly omit properties if the node has aliases or refs, I could consider trying to fix that, but I do not know how as of now. It also replaces the title keyword with a top level heading. This way you can add any node to your scratch buffer. This is equivalent to taking the note out of the drawer and putting it into your desk, the very first part of what I plan for this tool.
   - A similar function which prompts for org files in the zetteldesk but excluding org-roam files. Its behaviour is a bit different. No links are inserted as they are not needed, no part of the file is truncated as typically the first line is the title, the title is again changed to a top level heading, but as most big org files have some kind of structure to them, I also demote all their headings by 1, as their top level heading will be the title. This is part of an idea I had that this system should integrate with more than org-roam files (albeit that being the main plan) because your notes could also be in other org files.
   - For this reason, I plan to also add something that allows for pdfs to be inserted in the scratch buffer. Besides the notes themselves, the most important supplementary material is arguably pdfs. So the system needs to handle pdfs very well
   - Lastly, the only other kind of supportive material that I believe this should be able to handle is info buffers. Reading manuals through info is great. Capturing a link to a useful topic is made possible with my capture template for info buffers, but I believe for this application, I need to select a section from the manual and be able to automatically insert it to the zetteldesk. One difficulty I will face with this is that emacs only opens one info buffer and has its own navigation commands to navigate through it. Therefore, I cannot (at least by default) save a specific section to the zetteldesk (whose behaviour relies on a buffer local variable) and have a completion menu of all these info nodes and then insert what I need to the zetteldesk-scratch. I believe that if I look into it I can set up a pretty neat system for it, but it will require some work.

   Only other supportive material for any kind of work/research I could think of is source code files and browser pages. For source code files, it is in my opinion trivial to paste the code into an org mode source code block. I might automate it a bit better in the future, but for now I am not that interested in setting up something like this. For web pages, there really wouldn't be a point in inserting the web page verbatim, but only a link and some notes about it. This is already handled by org-roam protocol and that capture template of mine so if anything I will mention it and prompt to that capture template for what I think it should have. There is also screenshots and MS Office formats I guess but screenshots can be pasted into an org file from the clipboard and therefore require no automation and all MS Office formats aren't that readable in Emacs in the first place so they should be converted to pdf and handled by that imo. 
    

   #+BEGIN_SRC elisp :tangle zetteldesk.el

     (define-minor-mode zetteldesk-mode
       "Toggles the global zetteldesk-mode.

     When turned on, this mode initialises the *zetteldesk-scratch*
     buffer, a useful part of the whole zetteldesk workflow."
       nil
       :global t
       :group 'zetteldesk
       :lighter " zetteldesk")

     (defun zetteldesk--create-scratch-buffer ()
       "Create the zetteldesk-scratch buffer and put it in `org-mode'"
       (let ((buffer (generate-new-buffer "*zetteldesk-scratch*"))
	     (org-startup-with-latex-preview nil))
	 (with-current-buffer buffer
	   (org-mode))))

     (add-hook 'zetteldesk-mode-on-hook 'zetteldesk--create-scratch-buffer)

     (defun zetteldesk-switch-to-scratch-buffer ()
       "Open the zetteldesk-scratch buffer in a split with the current buffer"
       (interactive)
       (switch-to-buffer-other-window "*zetteldesk-scratch*"))

     (defun zetteldesk-node-insert-if-poi ()
       "Filter `org-roam-node-list' to only include files in the current
     `zetteldesk' that have the POI tag with `zetteldesk-node-p' and
     `org-roam-node-poi-p'. Then insert a link to every one of those nodes
     and seperate them with commas"
       (interactive)
       (let* ((init_list (org-roam-node-list))
	      (zetteldesk_nodes (cl-remove-if-not #'zetteldesk-node-p init_list))
	      (nodes_poi (cl-remove-if-not #'org-roam-node-poi-p zetteldesk_nodes)))
	 (while nodes_poi
	   (let* ((node (car nodes_poi))
		  (description (org-roam-node-formatted (car nodes_poi))))
	     (insert (org-link-make-string
		      (concat "id:" (org-roam-node-id (car nodes_poi)))
		      description))
	     (insert ", "))
	   (setq nodes_poi (cdr nodes_poi)))))

     (defun zetteldesk-insert-node-contents (&optional arg)
       "Select a node that is part of the current `zetteldesk', add a link
       to it at point and then insert its contents to the bottom of the 
       ,*zetteldesk-scratch* buffer after inserting a newline there. Remove
       the first 67 characters which is the properties section if it only
       contains the ID of the node as its unneeded and change the string
       ,#+title to a top level heading as its more practical when inserting
       the contents of multiple files.

     If given a `\\[universal-argument]' also switch to the *zetteldesk-scratch* buffer
     in a split."
       (interactive "P")
       (let* ((node (org-roam-node-read nil #'zetteldesk-node-p))
	      (file (org-roam-node-file node))
	      (description (org-roam-node-formatted node)))
	 (insert (org-link-make-string
		  (concat "id:" (org-roam-node-id node))
		  description))
	 (with-current-buffer "*zetteldesk-scratch*"
	   (goto-char (point-max))
	   (newline)
	   (insert-file-contents file nil 67)
	   (replace-string "#+title: " "* ")))
       (when (equal arg '(4))
	 (save-current-buffer
	   (switch-to-buffer-other-window "*zetteldesk-scratch*"))))

     (defun zetteldesk-insert-node-contents-without-link ()
       "\"Sister function\" of
       `zetteldesk-insert-node-contents'. Finds a node that is part of
       the `zetteldesk' and inserts its contents to the bottom of the
       zetteldesk-scratch buffer. This function differentiates itself,
       by the fact that it doesn't insert an ID link to the node in
       the current buffer and by the fact that it switches to the
       scratch buffer in a split without needing a
       `\\[universal-argument]'.

     For me, it makes sense a lot of the time to insert a link to the
     node inthe current buffer, especially if its an outlining
     buffer. But sometimes its not handy, and so, I just made this
     second iteration to fix that issue."
       (interactive)
       (let* ((node (org-roam-node-read nil #'zetteldesk-node-p))
	      (file (org-roam-node-file node)))
	 (with-current-buffer "*zetteldesk-scratch*"
	   (goto-char (point-max))
	   (newline)
	   (insert-file-contents file nil 67)
	   (replace-string "#+title: " "* ")))
       (switch-to-buffer-other-window "*zetteldesk-scratch*"))

     (defun zetteldesk-insert-org-file-contents (&optional arg)
       "Select an org buffer (excluding org-roam files) that is part of the
       current `zetteldesk', insert its contents to the
       ,*zetteldesk-scratch* buffer, make its title a top level heading and
       demote all of its headings by one level (since the title now acts as
       a top level heading).

     If given a `\\[universal-argument]' also switch to the
     ,*zetteldesk-scratch* buffer in a split"
       (interactive "P")
       (let* ((buffer (set-buffer (read-buffer "Zetteldesk Buffers: " nil nil #'zetteldesk-org-buffer-p)))
	      (file (buffer-file-name buffer)))
	 (set-buffer "*zetteldesk-scratch*")
	 (goto-char (point-max))
	 (save-excursion
	   (newline)
	   (insert-file-contents file))
	 (save-excursion
	   (while (not (org-next-visible-heading 1))
	     (org-metaright)))
	 (replace-string "#+title: " "* "))
       (when (equal arg '(4))
	 (switch-to-buffer-other-window "*zetteldesk-scratch*")))

     (defun zetteldesk-insert-link-to-pdf (&optional arg)
       "Select a pdf file that is part of the `zetteldesk' and prompt for a
       page in that pdf (defaults to page 1 if you don't care about the
       page).

     Then, in the zetteldesk-scratch buffer, insert at `point-max' a
     newline and then a new heading with its name consisting of the
     string \"Supportive Material - \" then the pdfs name, without the
     file structure or the extension and then the string
     \"(PDF)\". Then, insert a newline, the string \"Link to PDF: \"
     and then a link to the chosen pdf, in the correct page, with the
     description being the pdfs name without the file structure or the
     extension.

     Optionally, if given a `\\[universal-argument]' save the
     highlighted region in a variable and insert it after the heading
     but before the pdf link. This functionality serves the purpose of
     adding a \"description\" sort of thing to the pdf. Typically,
     when citing a pdf as supplementary info to an argument, there is
     something specific you want to take from the pdf. Therefore, this
     optional addition, adds that to the scratch buffer so you
     remember why it was useful."
       (interactive "P")
       (let* ((contents (buffer-substring (mark) (point)))
	      (pdf-buffer (set-buffer (read-buffer "Zetteldesk Pdfs: " nil nil #'zetteldesk-pdf-p)))
	      (file (buffer-file-name pdf-buffer))
	      (page (read-from-minibuffer "Page: " "1"))
	      (description (file-name-nondirectory (file-name-sans-extension file))))
	 (with-current-buffer "*zetteldesk-scratch*"
	   (goto-char (point-max))
	   (newline)
	   (org-insert-heading)
	   (insert "Supportive Material - " description " (PDF)")
	   (newline)
	   (when (equal arg '(4))
	     (insert contents)
	     (newline))
	   (insert "Link to PDF: "
		   (org-link-make-string
		    (concat "pdf:" file "::" page)
		    description)))))

   #+END_SRC

   #+RESULTS:
   : zetteldesk-insert-node-contents
   
** Providing the package
#+BEGIN_SRC elisp :tangle zetteldesk.el

  (provide 'zetteldesk)

#+END_SRC
   
* Providing the package to be loaded in init.el
  #+BEGIN_SRC elisp :tangle yes

    (provide 'zettelkasten)

  #+END_SRC
  
